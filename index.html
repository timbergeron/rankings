<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta id="viewportMeta" name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- Cache control meta tags -->
        <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
        <meta http-equiv="Pragma" content="no-cache">
        <meta http-equiv="Expires" content="0">
        <title>CIF-LA Volleyball Colley Rankings</title>
        <!-- Add Google Font Fugaz One -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Fugaz+One&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="style.css">
        <style>
            .league-rank {
                color: #17215f;
                font-weight: bold;
                cursor: help;
            }
        </style>
        <style>
            .custom-tooltip {
                position: absolute;
                background-color: #f8f9fa;
                border: 1px solid #ddd;
                padding: 8px 12px;
                border-radius: 4px;
                font-family: monospace;
                font-size: 12px;
                white-space: pre-wrap; /* Changed from pre to pre-wrap to allow text wrapping */
                max-width: 550px; /* Increased from 400px to 550px */
                z-index: 1000;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.15s ease-in-out;
            }

            /* Mobile-specific tooltip improvements */
            @media (hover: none) {
                .custom-tooltip {
                    padding: 12px 15px;
                    font-size: 14px;
                    max-width: 90%; /* Increased from 80% to 90% */
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                }
                
                .record-hover, .league-rank, [data-tooltip] {
                    cursor: pointer;
                    user-select: none;
                    -webkit-tap-highlight-color: transparent;
                }
                
                /* Special styling for Adj column tooltips on mobile - removed underlines */
                .adj-needs-adjustment .record-hover {
                    /* Removed dotted underline */
                }
                
                .adj-five-set-win .record-hover {
                    /* Removed dotted underline */
                }
                
                /* Enhance tap target size for better usability on mobile */
                .record-hover {
                    padding: 2px 0;
                }
            }
            
            .adj-needs-adjustment {
                color: #cc0000;
                font-weight: bold;
            }
            
            .adj-five-set-win {
                color: #007e33;
                font-weight: bold;
            }
            
            .adj-league-order {
                color: #800080 !important; /* Force purple color with !important */
                font-weight: bold;
            }
        </style>
        <style>
            /* Add a more specific rule for any spans within adj-league-order */
            .adj-league-order span,
            .adj-league-order .record-hover {
                color: #800080 !important;
                font-weight: bold;
            }
        </style>
        <style>
            .adj-needs-adjustment span,
            .adj-needs-adjustment .record-hover {
                color: #cc0000 !important;
            }
        </style>
        <!-- Add the favicon link in the document head -->
        <link rel="icon" href="cif.svg" type="image/svg+xml">
        <!-- Also add apple touch icon for iOS devices -->
        <link rel="apple-touch-icon" href="cif.svg">
        <!-- Font Awesome for icons -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
        <!-- Selector controls styles -->
        <style>
            /* Existing styles */
            
            /* Selector controls styles */
            .selector-controls {
                margin-bottom: 20px;
                padding: 15px;
                background-color: #f7f7f7;
                border-radius: 5px;
                border: 1px solid #ddd;
            }
            
            .selector-row {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
            }
            
            .selector-row:last-child {
                margin-bottom: 0;
            }
            
            .selector-label {
                flex: 0 0 65px;
                font-weight: bold;
                margin-right: 10px; /* Add padding between label and dropdown */
            }
            
            .selector-input {
                flex: 0 0 200px; /* Fixed width instead of flex-grow */
            }
            
            .selector-input select {
                width: 100%;
                padding: 8px;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 14px;
            }
            .selector-input select option:disabled {
                color: #999;
                background-color: #f5f5f5;
            }
            
            .exclude-playoff-btn {
                padding: 8px 15px;
                background-color: #f0f0f0;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 14px;
                color: #666;
                cursor: not-allowed;
                opacity: 0.8;
                width: 100%;
                text-align: center;
                margin-top: 5px;
            }
            
            /* Hypothetical results section styles */
            .hypothetical-selection {
                margin-top: 15px;
                display: flex;
                flex-direction: column;
                gap: 15px;
            }
            
            .hypothetical-table {
                width: 100%;
                max-width: 500px;
                margin: 0 auto 0 0; /* Change from centered to left-aligned */
                border-collapse: collapse;
            }
            
            .hypothetical-table th,
            .hypothetical-table td {
                padding: 8px;
                text-align: left;
                border-bottom: 1px solid #ddd;
            }
            
            .hypothetical-table th {
                background-color: #17215f; /* Changed to match the standard blue color */
                color: white; /* Added white text for better contrast */
                font-weight: bold;
            }
            
            .hypothetical-table select {
                width: 100%;
                padding: 8px;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 14px;
            }
            
            .generate-hypo-button {
                margin-top: 15px;
                padding: 10px 15px;
                background-color: #17215f; /* Changed to match the standard blue color */
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 16px;
                align-self: flex-start; /* Changed from center to left */
            }
            
            .generate-hypo-button:hover {
                background-color: #232f6e; /* Changed to match the standard hover blue */
            }
        </style>
        <style>
            .hypothetical-note {
                font-style: italic;
                color: #17215f;
                font-weight: bold;
                margin-top: 0;
                margin-bottom: 15px;
                font-size: 0.9em;
                padding: 5px 10px;
                background-color: #e6f2ff;
                border-left: 4px solid #17215f;
                border-radius: 3px;
            }
            
            .update-info {
                font-size: 14px;
                color: #444;
                margin-bottom: 15px;
                font-style: italic;
            }
            
            .match-highlight {
                color: #007e33;
                font-weight: bold;
            }
        </style>
        <style>
            .league-adj-span {
                color: #800080 !important;
            }
        </style>
        <style>
            .exempted-team-span {
                color: #cc0000 !important;
            }
        </style>
        <style>
            /* PURPLE for teams adjusted down due to league order */
            .adj-league-order-down,
            .adj-league-order-down span,
            .adj-league-order-down .record-hover,
            .league-adj-down-span {
                color: #800080 !important;
                font-weight: bold;
            }
        </style>
        <style>
            /* BLUE for teams adjusted up due to Best-of-3 win */
            .adj-best-of-3-win {
                color: #007bff; /* Bootstrap primary blue */
                font-weight: bold;
            }
            .adj-best-of-3-win span,
            .adj-best-of-3-win .record-hover {
                color: #007bff !important;
            }
        </style>
        <style>
            /* ORANGE for teams penalized due to Best-of-3 loss */
            .adj-bo3-loss-penalty {
                color: #fd7e14; /* Bootstrap orange */
                font-weight: bold;
            }
            .adj-bo3-loss-penalty span,
            .adj-bo3-loss-penalty .record-hover {
                color: #fd7e14 !important;
            }
        </style>
    </head>
<body>
    <div class="header">
        <img src="cif.svg" alt="CIF Logo" class="logo">
        <h1>CIF-LA VOLLEYBALL COLLEY RANKINGS</h1>
    </div>
    <div class="container">
        <h2>Generate Team Rankings</h2>                         
        
        <div class="selector-controls">
            <div class="selector-row">
                <div class="selector-label">Gender:</div>
                <div class="selector-input">
                    <select id="gender-select">
                        <option value="Boys">Boys</option>
                        <option value="Girls">Girls</option>
                    </select>
                </div>
            </div>
            
            <div class="selector-row">
                <div class="selector-label">Year:</div>
                <div class="selector-input">
                    <select id="year-select">
                        <option value="Current Year">Current Year</option>
                        <option value="2023-24">2023-24</option>
                        <option value="2022-23">2022-23</option>
                        <option value="2021-22">2021-22</option>
                        <option value="2020-21">2020-21</option>
                        <option value="2019-20">2019-20</option>
                        <option value="2018-19">2018-19</option>
                        <option value="2017-18">2017-18</option>
                        <option value="2016-17">2016-17</option>
                        <option value="2015-16">2015-16</option>
                        <option value="2014-15">2014-15</option>
                        <option value="2013-14">2013-14</option>
                        <option value="2012-13">2012-13</option>
                        <option value="2011-12">2011-12</option>
                        <option value="2010-11">2010-11</option>
                        <option value="2009-10">2009-10</option>
                        <option value="2008-09">2008-09</option>
                        <option value="2007-08">2007-08</option>
                        <option value="2006-07">2006-07</option>
                        <option value="2005-06">2005-06</option>
                        <option value="2004-05">2004-05</option>
                    </select>
                </div>
            </div>
            
            <div class="selector-row">
                <div class="selector-label"></div>
                <div class="selector-input">
                    <button id="exclude-playoff-btn" class="exclude-playoff-btn" disabled>Exclude Playoff Data</button>
                </div>
            </div>
        </div>
        
        <p>Google Sheets MaxPreps URL:</p>
        <input type="text" id="sheet-url" value="https://docs.google.com/spreadsheets/d/1etrnk_pEseefl4zTiikXR5CVz6yU0rkoRbvxQNvhPcs" />
        
        <div class="weight-controls">
            <h3>Match Format Weights</h3>
            <p>Adjust the importance of different match formats in the rankings:</p>
            
            <div class="weight-row">
                <div class="weight-label">Best of 5 match weight (3-0, 3-1, 3-2):</div>
                <div class="weight-input">
                    <input type="number" id="weight-bo5" min="0" max="1" step="0.1" value="1.0">
                </div>
            </div>
            
            <div class="weight-row">
                <div class="weight-label">5-Set Split Series Weight:</div>
                <div class="weight-input">
                    <input type="number" id="weight-bo5-split" min="0" max="1" step="0.1" value="0.0">
                </div>
            </div>
            
            <div class="weight-row">
                <div class="weight-label">Best of 3 match weight (2-0, 2-1):</div>
                <div class="weight-input">
                    <input type="number" id="weight-bo3" min="0" max="1" step="0.1" value="0.75">
                </div>
            </div>
            
            <div class="weight-row">
                <div class="weight-label">Tie-Set Weight (1-1):</div>
                <div class="weight-input">
                    <input type="number" id="weight-two" min="0" max="1" step="0.1" value="0.1">
                </div>
            </div>
            
            <div class="weight-row">
                <div class="weight-label">One-set match weight (1-0):</div>
                <div class="weight-input">
                    <input type="number" id="weight-one" min="0" max="1" step="0.1" value="0.3">
                </div>
            </div>
            
            <div class="weight-row">
                <div class="weight-label">Schedule Strength Weight:</div>
                <div class="weight-input">
                    <input type="number" id="weight-sos" min="0" max="1" step="0.05" value="0.2">
                </div>
            </div>
            
            <div class="weight-row">
                <div class="weight-label">Bo3 Loss Penalty:</div>
                <div class="weight-input">
                    <input type="number" id="weight-bo3-penalty" min="0" max="0.1" step="0.01" value="0.02">
                </div>
            </div>
        </div>
        
        <button id="generate-btn">Generate Rankings</button>
        
        <div class="loading" id="loading">
            <p>Calculating rankings...</p>
        </div>
        
        <div id="error-message"></div>
        
        <div id="results" style="display: none;">
            <div class="key-section">
                <h3>Key</h3>
                <ul>
                    <li><strong>Rating:</strong> Colley Matrix rating (0-1 scale) based on wins, losses, and match formats. More convincing wins (winning by more sets) are weighted more heavily than closer wins. For example, a 3-0 win is weighted 30% more than a 3-2 win, and a 2-0 win is weighted 20% more than a 2-1 win.</li>
                    <li><strong>Schedule:</strong> Weighted schedule strength calculated using adjusted ratings that prioritizes games against stronger opponents. The top 5 opponents receive the highest weights (7, 6, 5, 4, 3), with weights decreasing for lower-ranked opponents.</li>
                    <li>
                        <strong>Adj:</strong> Final adjusted rating derived through a multi-step process. Initial ratings are adjusted based on Head-to-Head results (affecting ranks), direct rating penalties are applied, and finally League Position rules assign final ratings. The adjustment types, applied sequentially where applicable, include:
                        <ol style="margin-top: 5px; margin-bottom: 5px; padding-left: 20px;">
                            <li><strong>League Position (<span class="adj-league-order-down" style="font-weight:bold;">Purple</span>):</strong> Final adjusted ratings assigned based on league rank within league blocks, using the ranks established by H2H rules (steps 1-3) and potentially modified by the special 5-set split logic.</li>
                            <li><strong>Best-of-3 Wins (<span class="adj-best-of-3-win" style="font-weight:bold;">Blue</span>):</strong> Ranks adjusted for Bo3 wins, *if not overridden by 5-set precedence*.</li>
                            <li><strong>Undefeated Teams (<span class="adj-needs-adjustment" style="font-weight:bold;">Red</span>):</strong> Ranks adjusted for undefeated teams (<15 wins) based on their best win (exemptions apply for >=15 wins).</li>
                            <li><strong>Rating Penalties (<span class="adj-bo3-loss-penalty" style="font-weight:bold;">Orange</span>):</strong> Direct rating reduction applied for unprotected Bo3 losses to lower-ranked teams.</li>
                            <li><strong>5-Set Wins (<span class="adj-five-set-win" style="font-weight:bold;">Green</span>):</strong> Ranks adjusted based on 5-set match results (including splits).</li>
                        </ol>
                        Adjustments avoid circular ties (e.g., A > B, B > C, C > A).
                    </li>
                    <li><strong>League Position:</strong> A team's rank within their own league (shown in parentheses next to team names). These standings are calculated using only best-of-5 format matches (3-0, 3-1, or 3-2 results) between teams in the same league. For teams with identical win percentages, the following tiebreakers are applied in order: (1) head-to-head results between the tied teams, (2) overall set differential (sets won minus sets lost). Teams remain tied only when all tiebreakers are equal.</li>
                </ul>
            </div>
            
            <h2>Rankings</h2>
            
            <table id="rankings-table">
                <thead>
                    <tr>
                        <th class="rank-column">Rank</th>
                        <th>Team</th>
                        <th id="rating-sort">Rating</th>
                        <th id="str-sort">Schedule</th>
                        <th id="adj-sort">Adj</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            
            <div class="section-divider">
                <h3>Teams With No Wins</h3>
                <p class="small-note">These teams are not included in the main rankings as they cannot be accurately ranked.</p>
                <table id="winless-teams-table">
                    <thead>
                        <tr>
                            <th id="winless-name-sort">Team</th>
                            <th id="winless-rating-sort">Rating</th>
                            <th id="winless-str-sort">Schedule</th>
                            <th id="winless-record-sort">Record</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            </div>
            
        <div class="section-divider">
            <h3>Processing Information <button id="copy-debug" title="Copy to clipboard" class="icon-button"><i class="fa-solid fa-copy"></i></button></h3>
            <div id="debug-info"></div>
        </div>
        
        <div class="section-divider"> <!-- Added section divider -->
            <h3>Top 10 Rule Adjustments <button id="copy-top10-adj" title="Copy to clipboard" class="icon-button"><i class="fa-solid fa-copy"></i></button></h3>
            <div id="top10-adj-info" class="debug-info-like"></div>
        </div>
        
    </div> <!-- Closing tag for the main container -->

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Add favicon
            addFavicon();
            
            const generateBtn = document.getElementById('generate-btn');
            const resultsDiv = document.getElementById('results');
            const errorMessageDiv = document.getElementById('error-message');
            const loadingDiv = document.getElementById('loading');
            const debugInfoDiv = document.getElementById('debug-info');
            
            // Set up copy-to-clipboard functionality
            const copyDebugBtn = document.getElementById('copy-debug');
            if (copyDebugBtn) {
                copyDebugBtn.addEventListener('click', function() {
                    const debugContent = document.getElementById('debug-info').innerText;
                    navigator.clipboard.writeText(debugContent).then(function() {
                        // Temporarily change the button icon to indicate success
                        const iconElement = copyDebugBtn.querySelector('i');
                        iconElement.className = 'fa-solid fa-check';
                        setTimeout(function() {
                            iconElement.className = 'fa-solid fa-copy';
                        }, 1500);
                    }).catch(function(err) {
                        console.error('Could not copy text: ', err);
                        alert('Failed to copy debug information to clipboard');
                    });
                });
            }
            
            // Set up copy-to-clipboard for Top 10 Adjustments
            const copyTop10AdjBtn = document.getElementById('copy-top10-adj');
            if (copyTop10AdjBtn) {
                copyTop10AdjBtn.addEventListener('click', function() {
                    const top10Content = document.getElementById('top10-adj-info').innerText;
                    navigator.clipboard.writeText(top10Content).then(function() {
                        // Temporarily change the button icon to indicate success
                        const iconElement = copyTop10AdjBtn.querySelector('i');
                        iconElement.className = 'fa-solid fa-check';
                        setTimeout(function() {
                            iconElement.className = 'fa-solid fa-copy';
                        }, 1500);
                    }).catch(function(err) {
                        console.error('Could not copy text: ', err);
                        alert('Failed to copy Top 10 Adjustments to clipboard');
                    });
                });
            }
            
            // Hardcoded API key
            const apiKey = "AIzaSyDFYwFR-9NXvcH10U4ocestyje7N91FICU";
            
            // Track current data and sort state
            let currentRankings = [];
            let currentWinlessTeams = [];
            let sortState = {
                column: 'adj', // Default sort by adjusted ratings
                direction: 'desc'
            };
            
            // Hoisted variable for pre-league ratings needed by logTop10Adjustments
            let preLeagueAdjRatings = {}; 
            
            // --> Add global variable for team paths <--
            let globalTeamPaths = {};
            
            // Additional sort state variables for other tables
            let leagueSortState = {
                column: 'weighted',
                direction: 'desc'
            };

            let winlessSortState = {
                column: 'rating',
                direction: 'desc'
            };
            
            // Add global variables to store needed data for sorting
            let globalTeamWins = {};
            let globalTeamMap = {};
            
            // Store matches globally
            let globalMatches = [];
            
            // Store hypothetical matches separately to ensure they're not lost on reloading
            let hypotheticalMatches = [];
            
            // Store last update info from the spreadsheet
            let lastUpdateInfo = "";
            
            // Add global variables to track data for hypothetical processing
            let globalTeamRecords = {};
            let globalOpponentRatings = {};
            let globalFormatStats = {
                bestOf5: 0,
                bestOf3: 0,
                twoSets: 0,
                oneSets: 0
            };
            
            // Helper function to generate MaxPreps URL
            function getMaxPrepsUrl(teamPath) {
                if (!teamPath) {
                    logDebug(`No path provided for MaxPreps URL generation.`);
                    return null;
                }
                
                const baseUrl = "https://www.maxpreps.com";
                const selectedYear = document.getElementById('year-select').value;
                const selectedGender = document.getElementById('gender-select').value;

                // Determine year segment
                let yearSegment = "schedule/"; // Default for Current Year
                if (selectedYear !== "Current Year") {
                    const yearParts = selectedYear.split('-');
                    if (yearParts.length === 2) {
                        const shortYear = yearParts[0].slice(-2) + '-' + yearParts[1].slice(-2);
                        yearSegment = `${shortYear}/schedule/`; // e.g., 23-24/schedule/
                    }
                }

                // Determine gender/sport segment
                const genderLower = selectedGender.toLowerCase(); // 'boys' or 'girls'
                const genderSportSegment = `volleyball/${genderLower}/`; // e.g., volleyball/boys/

                // Clean the school path segment (remove leading/trailing slashes)
                const cleanedSchoolPath = teamPath.replace(/^\/+|\/+$/g, ''); // e.g., los-angeles/eagle-rock-eagles

                // Assemble the full URL
                const maxPrepsUrl = `${baseUrl}/ca/${cleanedSchoolPath}/${genderSportSegment}${yearSegment}`;
                
                logDebug(`Generated MaxPreps URL for path ${teamPath}: ${maxPrepsUrl}`);
                return maxPrepsUrl;
            }
            
            function logDebug(message, isSuccess = false) {
                const timestamp = new Date().toLocaleTimeString();
                const logElement = document.createElement('div');
                
                if (isSuccess) {
                    logElement.className = 'success';
                }
                
                logElement.textContent = `[${timestamp}] ${message}`;
                debugInfoDiv.appendChild(logElement);
                console.log(`[${timestamp}] ${message}`);
            }
            
            // Auto-generate rankings on page load
            window.addEventListener('load', function() {
                // Set initial sort indicator before generating rankings
                updateSortIndicator();
                
                // Set Boys and Current Year as default
                document.getElementById('gender-select').value = 'Boys';
                document.getElementById('year-select').value = 'Current Year';
                
                // Then generate rankings
                generateBtn.click();
            });
            
            // Add event listeners for the dropdowns to regenerate rankings when changed
            document.getElementById('gender-select').addEventListener('change', function() {
                generateBtn.click();
            });
            
            document.getElementById('year-select').addEventListener('change', function() {
                generateBtn.click();
            });
            
            // Setup sort column click handlers
            document.getElementById('rating-sort').addEventListener('click', function() {
                sortRankings('rating');
            });
            
            document.getElementById('str-sort').addEventListener('click', function() {
                sortRankings('str');
            });
            
            document.getElementById('adj-sort').addEventListener('click', function() {
                sortRankings('adj');
            });
            
            function sortRankings(column) {
                // Don't do anything if there are no rankings yet
                if (!currentRankings || currentRankings.length === 0) return;
    
                // Toggle sort direction if clicking the same column
    if (sortState.column === column) {
        sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
    } else {
                    // Save the old column for potential styling changes
                    const oldColumn = sortState.column;
                    
                    // Set the new column and default direction (descending for rating columns)
        sortState.column = column;
        sortState.direction = 'desc'; // Default to descending for all columns
                    
                    // Extra cleanup when switching from adj column
                    if (oldColumn === 'adj') {
                        fixIndicatorPlacement(false);
                    }
    }
    
                console.log(`Sort state updated: column=${sortState.column}, direction=${sortState.direction}`);
                
                // Sort the rankings array
                currentRankings.sort((a, b) => {
                    const thElement = document.getElementById(`${column}-sort`);
                    if (thElement) {
                // Reset all sort indicators
                document.querySelectorAll('th').forEach(th => {
                    th.classList.remove('sort-indicator');
                    th.classList.remove('sort-indicator-asc');
                            th.classList.remove('active-sort');
                });
    
                        // Add sort indicator and active class to current column
                        thElement.classList.add('active-sort');
        thElement.classList.add(sortState.direction === 'asc' ? 'sort-indicator-asc' : 'sort-indicator');
    }
    
    if (column === 'rating') {
            return sortState.direction === 'asc' ? 
                a.rating - b.rating : 
                b.rating - a.rating;
    } else if (column === 'str') {
            const strA = a.scheduleStrength || 0;
            const strB = b.scheduleStrength || 0;
            return sortState.direction === 'asc' ? 
                strA - strB : 
                strB - strA;
    } else if (column === 'adj') {
            return sortState.direction === 'asc' ? 
                            a.adjustedRating - b.adjustedRating :
                            b.adjustedRating - a.adjustedRating;
                    } else {
                        // Default case (shouldn't happen with current code)
                        return 0;
                    }
                });
                
                // Redisplay the rankings with the new sort
                displayRankings(currentRankings, globalTeamWins, globalTeamMap, globalMatches);
                
                // Fix indicator placement for Adj column
                fixIndicatorPlacement(sortState.column === 'adj');
                
                // Ensure schedule strength values are displayed correctly
                ensureScheduleStrengthDisplay();
                
                // Initialize all tooltips
                initializeAllTooltips();
            }
            
            function updateSortIndicator() {
                console.log(`Updating sort indicator for column: ${sortState.column}`);
                
                // Reset all sort indicators and active class
                document.querySelectorAll('th').forEach(th => {
                    th.classList.remove('sort-indicator');
                    th.classList.remove('sort-indicator-asc');
                    th.classList.remove('active-sort');
                });
                
                // Add sort indicator and active class to current sort column
                const thElement = document.getElementById(`${sortState.column}-sort`);
                console.log(`Found element for ${sortState.column}:`, thElement);
                
                if (thElement) {
                    thElement.classList.add(sortState.direction === 'asc' ? 'sort-indicator-asc' : 'sort-indicator');
                    thElement.classList.add('active-sort');
                    console.log(`Applied classes to ${sortState.column} column`);
                } else {
                    console.error(`Could not find element with ID: ${sortState.column}-sort`);
                }
}
            
            generateBtn.addEventListener('click', function() {
                // Reset previous results and errors
                errorMessageDiv.textContent = '';
                resultsDiv.style.display = 'none';
                debugInfoDiv.innerHTML = '';
                loadingDiv.style.display = 'block';
                
                const sheetUrl = document.getElementById('sheet-url').value.trim();
                if (!sheetUrl) {
                    errorMessageDiv.textContent = 'Please enter a Google Sheets URL';
                    loadingDiv.style.display = 'none';
                    return;
                }
                
                // Get weight values
                const weightBo5 = parseFloat(document.getElementById('weight-bo5').value);
                const weightBo5Split = parseFloat(document.getElementById('weight-bo5-split').value);
                const weightBo3 = parseFloat(document.getElementById('weight-bo3').value);
                const weightTwo = parseFloat(document.getElementById('weight-two').value);
                const weightOne = parseFloat(document.getElementById('weight-one').value);
                const weightBo3Penalty = parseFloat(document.getElementById('weight-bo3-penalty').value); // Read penalty weight
                const weightSos = parseFloat(document.getElementById('weight-sos').value);
                
                // Validate weights
                if (isNaN(weightBo5) || isNaN(weightBo5Split) || isNaN(weightBo3) || isNaN(weightTwo) || isNaN(weightOne) || isNaN(weightBo3Penalty) || isNaN(weightSos)) {
                    errorMessageDiv.textContent = 'Please enter valid numbers for all weights';
                    loadingDiv.style.display = 'none';
                    return;
                }
                
                // Extract the sheet ID from the URL
                let sheetId;
                try {
                    const urlParts = sheetUrl.split('/');
                    const idIndex = urlParts.indexOf('d') + 1;
                    sheetId = urlParts[idIndex];
                    
                    logDebug(`Extracted Sheet ID: ${sheetId}`);
                } catch (e) {
                    errorMessageDiv.textContent = 'Invalid Google Sheets URL format';
                    loadingDiv.style.display = 'none';
                    return;
                }
                
                // First, try to get information about the spreadsheet to find sheet names
                const spreadsheetInfoUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}?key=${apiKey}`;
                
                logDebug(`Fetching spreadsheet information...`);
                
                fetch(spreadsheetInfoUrl)
                    .then(response => {
                        if (!response.ok) {
                            logDebug(`Response status: ${response.status}`);
                            throw new Error(`Could not access the spreadsheet. Status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(sheetInfo => {
                        logDebug(`Spreadsheet info received. Title: ${sheetInfo.properties.title}`);
                        
                        // Get all sheet names for determining available options
                        const allSheetNames = sheetInfo.sheets.map(sheet => sheet.properties.title);
                        logDebug(`Available sheets: ${allSheetNames.join(', ')}`);
                        
                        // Update dropdown options based on available sheets
                        updateDropdownOptions(allSheetNames);
                        
                        // Get the selected gender and year
                        const selectedGender = document.getElementById('gender-select').value;
                        const selectedYear = document.getElementById('year-select').value;
                        
                        // Determine the sheet name based on selections
                        let sheetName;
                        if (selectedYear === "Current Year") {
                            sheetName = `${selectedGender} Current Year`;
                        } else {
                            sheetName = `${selectedGender} ${selectedYear}`;
                        }
                        
                        logDebug(`Selected data sheet: ${sheetName}`);
                        
                        // Check if the selected sheet exists
                        const sheetExists = allSheetNames.includes(sheetName);
                        
                        if (!sheetExists) {
                            // Fallback to "Matches" sheet if selected sheet doesn't exist
                            logDebug(`Sheet "${sheetName}" not found. Falling back to "Matches" sheet.`);
                            sheetName = "Matches";
                        }
                        
                        // Now get the data from the selected sheet
                        const sheetDataUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${encodeURIComponent(sheetName)}?key=${apiKey}`;
                        
                        logDebug(`Fetching data from sheet: ${sheetName}...`);
                        
                        return fetch(sheetDataUrl);
                    })
                    .then(response => {
                        if (!response.ok) {
                            logDebug(`Response status: ${response.status}`);
                            throw new Error(`Could not access the sheet data. Status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(sheetData => {
                        logDebug(`Sheet data received. Processing ${sheetData.values.length} rows...`, true);
                        
                        // Check for update info in column F of first row
                        if (sheetData.values.length > 0 && sheetData.values[0].length > 5) {
                            lastUpdateInfo = sheetData.values[0][5] ? sheetData.values[0][5].trim() : "";
                            logDebug(`Found update info: ${lastUpdateInfo}`);
                        }
                        
                        // Process the data
                        const matches = [];
                        const teamSet = new Set();
                        const formatStats = {
                            bestOf5: 0,
                            bestOf3: 0,
                            twoSets: 0,
                            oneSets: 0
                        };
                        
                        // For tracking team records and schedule strength
                        const teamRecords = {};
                        const opponentRatings = {};
                        const teamWins = {}; // Track which teams each team has beaten
                        
                        // Skip header row if it looks like a header
                        const startRow = 
                            sheetData.values[0] && 
                            typeof sheetData.values[0][0] === 'string' && 
                            (sheetData.values[0][0].toLowerCase().includes('date') || 
                             isNaN(parseInt(sheetData.values[0][0].charAt(0)))) ? 1 : 0;
                        
                        logDebug(`Starting from row: ${startRow + 1} (${startRow === 0 ? 'No header detected' : 'Header row skipped'})`);
                        
                        for (let i = startRow; i < sheetData.values.length; i++) {
                            const row = sheetData.values[i];
                            if (row.length < 5) {
                                logDebug(`Row ${i + 1} skipped - not enough columns: ${row.join(', ')}`);
                                continue;
                            }
                            
                            const date = row[0] ? row[0].trim() : '';
                            const teamA = row[1] ? row[1].trim() : '';
                            const teamASets = parseInt(row[2], 10);
                            const teamB = row[3] ? row[3].trim() : '';
                            const teamBSets = parseInt(row[4], 10);
                            
                            if (!teamA || !teamB || isNaN(teamASets) || isNaN(teamBSets)) {
                                logDebug(`Row ${i + 1} skipped - invalid data: ${row.join(', ')}`);
                                continue;
                            }
                            
                            // Initialize team records and opponent lists if needed
                            if (!teamRecords[teamA]) {
                                teamRecords[teamA] = { wins: 0, losses: 0, ties: 0 };
                                opponentRatings[teamA] = [];
                                teamWins[teamA] = [];
                            }
                            if (!teamRecords[teamB]) {
                                teamRecords[teamB] = { wins: 0, losses: 0, ties: 0 };
                                opponentRatings[teamB] = [];
                                teamWins[teamB] = [];
                            }
                            
                            // Update team records and track wins
                            if (teamASets > teamBSets) {
                                teamRecords[teamA].wins++;
                                teamRecords[teamB].losses++;
                                teamWins[teamA].push(teamB); // A beat B
                            } else if (teamBSets > teamASets) {
                                teamRecords[teamB].wins++;
                                teamRecords[teamA].losses++;
                                teamWins[teamB].push(teamA); // B beat A
                            } else {
                                teamRecords[teamA].ties++;
                                teamRecords[teamB].ties++;
                            }
                            
                            // Add teams to opponent lists for schedule strength
                            opponentRatings[teamA].push(teamB);
                            opponentRatings[teamB].push(teamA);
                            
                            teamSet.add(teamA);
                            teamSet.add(teamB);
                            
                            // Determine match format based on sets
                            const totalSets = teamASets + teamBSets;
                            let format;
                            
                            // Debug the format determination
                            logDebug(`Determining format for ${teamA} (${teamASets}) vs ${teamB} (${teamBSets}) - Total sets: ${totalSets}`);
                            
                            if (totalSets <= 1) {
                                format = 1;
                                formatStats.oneSets++;
                            } else if (totalSets === 2) {
                                // Handle 2-0 matches as Best of 3
                                if (teamASets === 2 && teamBSets === 0 || teamBSets === 2 && teamASets === 0) {
                                    format = 3;
                                    formatStats.bestOf3++;
                                } else {
                                    // This is a 1-1 tie match
                                    format = 2;
                                    formatStats.twoSets++;
                                }
                            } else if (totalSets === 3 && Math.max(teamASets, teamBSets) === 2) {
                                // Only count as best of 3 if the max score is 2 (2-1 score)
                                format = 3;
                                formatStats.bestOf3++;
                            } else {
                                // Any other case (including 3-0) is best of 5
                                format = 5;
                                formatStats.bestOf5++;
                                // Add debug log for 5-set matches
                                logDebug(`Detected 5-set match: ${teamA} (${teamASets}) vs ${teamB} (${teamBSets})`);
                            }
                            
                            matches.push({
                                date,
                                teamA,
                                teamASets,
                                teamB,
                                teamBSets,
                                format
                            });
                            
                            logDebug(`Added match: ${teamA} (${teamASets}) vs ${teamB} (${teamBSets}) - Format: ${format}`);
                        }
                        
                        // Add any hypothetical matches to the matches array
                        if (hypotheticalMatches.length > 0) {
                            logDebug(`Adding ${hypotheticalMatches.length} hypothetical matches to the calculations`);
                            
                            for (const hypoMatch of hypotheticalMatches) {
                                matches.push(hypoMatch);
                                
                                // Update team records for the hypothetical match
                                if (!teamRecords[hypoMatch.teamA]) {
                                    teamRecords[hypoMatch.teamA] = { wins: 0, losses: 0, ties: 0 };
                                }
                                if (!teamRecords[hypoMatch.teamB]) {
                                    teamRecords[hypoMatch.teamB] = { wins: 0, losses: 0, ties: 0 };
                                }
                                
                                // Update win/loss records
                                if (hypoMatch.teamASets > hypoMatch.teamBSets) {
                                    teamRecords[hypoMatch.teamA].wins++;
                                    teamRecords[hypoMatch.teamB].losses++;
                                    
                                    // Update team wins tracking
                                    if (!teamWins[hypoMatch.teamA]) {
                                        teamWins[hypoMatch.teamA] = [];
                                    }
                                    if (!teamWins[hypoMatch.teamA].includes(hypoMatch.teamB)) {
                                        teamWins[hypoMatch.teamA].push(hypoMatch.teamB);
                                    }
                                } else if (hypoMatch.teamBSets > hypoMatch.teamASets) {
                                    teamRecords[hypoMatch.teamB].wins++;
                                    teamRecords[hypoMatch.teamA].losses++;
                                    
                                    // Update team wins tracking
                                    if (!teamWins[hypoMatch.teamB]) {
                                        teamWins[hypoMatch.teamB] = [];
                                    }
                                    if (!teamWins[hypoMatch.teamB].includes(hypoMatch.teamA)) {
                                        teamWins[hypoMatch.teamB].push(hypoMatch.teamA);
                                    }
                                } else {
                                    // Tie
                                    teamRecords[hypoMatch.teamA].ties++;
                                    teamRecords[hypoMatch.teamB].ties++;
                                }
                                
                                // Update format stats
                                if (hypoMatch.format === 5) {
                                    formatStats.bestOf5++;
                                } else if (hypoMatch.format === 3) {
                                    formatStats.bestOf3++;
                                } else if (hypoMatch.format === 2) {
                                    formatStats.twoSets++;
                                } else if (hypoMatch.format === 1) {
                                    formatStats.oneSets++;
                                }
                            }
                        }
                        
                        if (matches.length === 0) {
                            throw new Error('No valid matches found in the data');
                        }
                        
                        logDebug(`Total matches found: ${matches.length}`, true);
                        logDebug(`Match formats summary: Best of 5: ${formatStats.bestOf5}, Best of 3: ${formatStats.bestOf3}, Two-sets: ${formatStats.twoSets}, One-set: ${formatStats.oneSets}`);
                        logDebug(`Total teams found: ${teamSet.size}`, true);
                        
                        // Convert the team set to an array and create a mapping
                        const teams = Array.from(teamSet);
                        const teamToIndex = {};
                        teams.forEach((team, index) => {
                            teamToIndex[team] = index + 1;
                        });
                        
                        // Weight factors from user input
                        const weightFactors = {
                            5: weightBo5,
                            '5split': weightBo5Split,
                            3: weightBo3,
                            2: weightTwo,
                            1: weightOne,
                            'bo3penalty': weightBo3Penalty, // Add penalty to weightFactors
                            sos: weightSos
                        };
                        
                        logDebug(`Using weights - Best of 5: ${weightBo5}, 5-Set Split Series: ${weightBo5Split}, Best of 3: ${weightBo3}, Tie-Set: ${weightTwo}, One-set: ${weightOne}, Bo3 Loss Penalty: ${weightBo3Penalty}, Schedule Strength: ${weightSos}`);
                        
                        // Calculate rankings
                        logDebug(`Calculating rankings...`);
                        const rankings = calculateVolleyballRankings(teams, teamToIndex, matches, weightFactors);
                        
                        // Calculate schedule strength
                        calculateScheduleStrength(rankings, opponentRatings, teamToIndex);
                        
                        // Add team records to rankings
                        rankings.forEach(team => {
                            const record = teamRecords[team.name];
                            if (record) {
                                team.record = record;
                            }
                        });
                        
                        // Store matches globally
                        globalMatches = matches;
                        
                        logDebug(`Set globalMatches with ${globalMatches.length} matches`);
                        
                        // Calculate initial adjusted rankings (without 5-set for now)
                        calculateAdjustedRankings(rankings, teamWins, weightFactors, false); // Pass false to disable 5-set here

                        // Separate teams with wins
                        const teamsWithWins = rankings.filter(team => team.record && team.record.wins > 0);
                        const winlessTeams = rankings.filter(team => !team.record || team.record.wins === 0);

                        // Store pre-league ratings for logging
                        preLeagueAdjRatings = {};
                        teamsWithWins.forEach(team => {
                            preLeagueAdjRatings[team.name] = { 
                                rating: team.rating, 
                                adjustedRating: team.adjustedRating, 
                                scheduleStrength: team.scheduleStrength 
                            };
                        });

                        // === Start of New Adjustment Order ===

                        // ① ── First, apply LEAGUE rule and update ratings ───
                        fetchLeagueData(sheetId, apiKey, rankings, matches, teamWins, globalTeamMap)
                            .then(async () => { // Use async here to wait for league application
                                logDebug("Applying League Rank Reorder...");
                                await applyLeagueRankReorder(teamsWithWins); // Ensure this finishes

                                // Re-score after league ordering
                                logDebug("Calculating adjusted ratings after League rule...");
                                calculateAdjustedRatings(teamsWithWins, weightFactors);

                                // ② ── Mid-tier rules (Bo3, Undefeated) ──────
                                logDebug("Applying Best-of-3 Match Adjustments...");
                                applyBestOf3MatchAdjustments(matches, teamWins, teamsWithWins);

                                logDebug("Applying Undefeated Team Adjustments...");
                                applyUndefeatedTeamAdjustments(teamWins, teamsWithWins);

                                // Re-score after Bo3 & Undefeated
                                logDebug("Calculating adjusted ratings after Bo3/Undefeated rules...");
                                calculateAdjustedRatings(teamsWithWins, weightFactors);

                                // ③ ── LAST: 5-set rule ──────────────────────
                                logDebug("Applying 5-Set Match Adjustments...");
                                apply5SetMatchAdjustments(matches, teamWins, teamsWithWins, weightFactors);

                                // Final re-score after all adjustments
                                logDebug("Calculating final adjusted ratings after 5-Set rule...");
                                calculateAdjustedRatings(teamsWithWins, weightFactors);

                                // === End of New Adjustment Order ===

                                // Recalculate schedule strength using the final adjusted ratings
                                logDebug("Recalculating schedule strength with final adjusted ratings...");
                                calculateScheduleStrength(rankings, opponentRatings, teamToIndex);

                                // Force a refresh of the schedule strength values (optional, but helps ensure display updates)
                                const tempSortState = {...sortState};
                                sortState.column = 'str';
                                sortState.direction = 'desc';
                                const tempRankings = [...teamsWithWins];
                                tempRankings.sort((a, b) => (b.scheduleStrength || 0) - (a.scheduleStrength || 0));
                                sortState.column = tempSortState.column;
                                sortState.direction = tempSortState.direction;

                                // Final sort based on user's current selection (usually 'adj')
                                teamsWithWins.sort((a, b) => {
                                    const adjA = a.adjustedRating !== undefined ? a.adjustedRating : a.rating;
                                    const adjB = b.adjustedRating !== undefined ? b.adjustedRating : b.rating;
                                    return sortState.direction === 'asc' ? adjA - adjB : adjB - adjA;
                                });

                                // Store final rankings for display and sorting
                                currentRankings = teamsWithWins;
                                currentWinlessTeams = winlessTeams;

                                // Also process winless teams to ensure their schedule strength values are correct
                                if (winlessTeams.length > 0) {
                                    winlessTeams.sort((a, b) => (b.scheduleStrength || 0) - (a.scheduleStrength || 0));
                                    winlessTeams.sort((a, b) => b.rating - a.rating); // Default sort for winless
                                }

                                // Update sort indicators
                                updateSortIndicator();

                                // Log final top teams schedule strength
                                logDebug(`Final schedule strength values after all adjustments:`);
                                if (currentRankings.length > 0) {
                                    const topTeams = currentRankings.slice(0, Math.min(5, currentRankings.length));
                                    topTeams.forEach(team => {
                                        logDebug(`  ${team.name}: Adj Rating ${team.adjustedRating.toFixed(3)}, Schedule Strength ${team.scheduleStrength.toFixed(3)}`);
                                    });
                                }

                                // Display final results
                                displayRankings(currentRankings, teamWins, globalTeamMap, globalMatches);
                                displayWinlessTeams(currentWinlessTeams);

                                // Ensure display is correct and initialize tooltips after a delay
                                setTimeout(() => {
                                    ensureScheduleStrengthDisplay();
                                    initializeAllTooltips();
                                    logDebug(`Delayed tooltip initialization complete`);
                                }, 100);

                                // *** Log Top 10 Adjustments ***
                                logDebug("Logging Top 10 Adjustments...");
                                logTop10Adjustments(currentRankings, preLeagueAdjRatings);

                                // Display the final results section
                                loadingDiv.style.display = 'none';
                                resultsDiv.style.display = 'block';
                                logDebug(`Rankings calculation complete!`, true);

                                // Create and setup the matchup prediction section
                                createMatchupPredictionSection();
                                populateTeamDropdowns(currentRankings, currentWinlessTeams);
                                setupPredictionHandlers();
                            })
                            .catch(error => {
                                // This catch block now handles errors from fetchLeagueData OR any subsequent adjustment steps
                                logDebug(`Error during adjustment phase: ${error.message}`);
                                errorMessageDiv.textContent = `Error during ranking adjustments: ${error.message}`;
                                loadingDiv.style.display = 'none';
                                resultsDiv.style.display = 'block'; // Still show partial results if possible
                                console.error(error);
                            });
                    })
                    .catch(error => {
                        // This catch block handles errors from fetching sheet data
                        errorMessageDiv.textContent = `Error fetching data: ${error.message}`;
                        loadingDiv.style.display = 'none';
                        logDebug(`Error fetching data: ${error.message}`);
                        console.error(error);
                    });
            });

            function calculateAdjustedRankings(rankings, teamWins, weightFactors, enableFiveSet = false) { // Add enableFiveSet parameter, default false
                // Create a map of teams to their ranking index
                const teamToRank = {};
                rankings.forEach((team, index) => {
                    teamToRank[team.name] = index + 1;
                });
                
                // Blend schedule strength into rating for more balanced rankings
                const SOS_WEIGHT = weightFactors.sos !== undefined ? weightFactors.sos : 0.2; // Get from UI or default to 0.2
                logDebug(`Blending schedule strength into ratings with weight: ${SOS_WEIGHT}`);
                
                rankings.forEach(team => {
                    // Create blended score that accounts for schedule strength
                    team.blendedScore = (1 - SOS_WEIGHT) * team.rating + 
                                       SOS_WEIGHT * (team.scheduleStrength || 0);
                               
                    logDebug(`${team.name}: Rating ${team.rating.toFixed(3)}, Schedule Strength ${(team.scheduleStrength || 0).toFixed(3)}, Blended ${team.blendedScore.toFixed(3)}`);
                });
                
                // Sort teams by blended score instead of just rating
                rankings.sort((a, b) => b.blendedScore - a.blendedScore);
                
                // Track head-to-head 5-set match wins for ranking adjustments
                // Make sure we have access to globalMatches, or use an empty array as fallback
                const matches = globalMatches || [];
                const fiveSetWins = findFiveSetMatchWins(matches);
                const fiveSetLosses = findFiveSetMatchLosses(matches); // Get 5-set match losses
                
                // Initialize adjusted ranks as the same as original ranking
                rankings.forEach((team, index) => {
                    // Assign a default adjusted rank same as current rank
                    team.adjustedRank = index + 1;
                });
                
                // Process head-to-head 5-set match results
                // We do this after initializing adjusted ranks
                if (enableFiveSet) { // <-- ADD THIS GUARD
                    logDebug(`Starting 5-set match win adjustments in calculateAdjustedRankings (total teams: ${rankings.length})...`);
                    let fiveSetAdjustmentsCount = 0;

                    for (let i = 0; i < rankings.length; i++) {
                        const teamA = rankings[i];

                        for (let j = i + 1; j < rankings.length; j++) {
                            const teamB = rankings[j];

                            // Check for 5-set match win from lower ranked team over higher ranked team
                            if (fiveSetWins[teamB.name] && fiveSetWins[teamB.name].includes(teamA.name)) {
                                logDebug(`Potential adjustment: ${teamB.name} (rank ${j+1}) beat ${teamA.name} (rank ${i+1}) in a 5-set match`);

                                // Check if there's a reciprocal match (team also lost to the same team in 5 sets)
                                const hasReciprocalLoss = fiveSetLosses[teamB.name] && fiveSetLosses[teamB.name].includes(teamA.name);

                                if (hasReciprocalLoss) {
                                    // Get the split weight from the weight factors or use 0.2 as default
                                    const splitWeight = weightFactors?.['5split'] !== undefined ? weightFactors['5split'] : 0.2;

                                    // Skip completely if split weight is 0
                                    if (splitWeight <= 0) {
                                        logDebug(`⚠️ Skipping adjustment for ${teamB.name} over ${teamA.name} - split weight is ${splitWeight}`);
                                        continue;
                                    }

                                    logDebug(`⚠️ Found split series between ${teamB.name} and ${teamA.name}, applying ${splitWeight * 100}% weight`);

                                    // Team B (lower ranked) beat Team A (higher ranked) in a 5-set match
                                    // But they also lost to Team A in a 5-set match, so we apply partial adjustment

                                    // Check if there's a circular dependency (informational only for split series)
                                    const hasCircular = hasCircularDependency(teamA.name, teamB.name, teamWins);
                                    logDebug(`  Circular dependency check: ${hasCircular ? 'FOUND but IGNORING for split series' : 'None'}`);

                                    // For split series, we ignore circular dependencies and apply the adjustment anyway
                                    // (if A beat C, C beat B, but B beat A, we still adjust since they directly split matches)
                                    // Calculate a partial adjustment based on split weight
                                    logDebug(`  PARTIAL ADJUSTING: ${teamB.name} (rank ${j+1}) based on split series with ${teamA.name} using ${splitWeight * 100}% weight`);

                                    // Only adjust if not already adjusted (e.g., by undefeated rule)
                                    if (teamB.adjustedRank === j + 1) {
                                        // Calculate how far to move based on the split weight
                                        const currentRank = teamB.adjustedRank;
                                        const targetRank = i; // Target is team A's initial rank index
                                        const rankDiff = currentRank - targetRank;

                                        // Cap the splitWeight at 1.0 for movement calculation
                                        const effectiveWeight = Math.min(splitWeight, 1.0);

                                        // Calculate the new rank applying the split weight
                                        // We adjust the rank *value*, not the index directly
                                        const newRank = currentRank - (rankDiff * effectiveWeight);

                                        teamB.adjustedRank = newRank;
                                        teamB.adjustedDueToFiveSet = true;
                                        teamB.beatInFiveSet = `${teamA.name} (Split Series, ${(splitWeight * 100).toFixed(0)}% weight)`;
                                        fiveSetAdjustmentsCount++;
                                        logDebug(`⚠️ Partial adjustment applied! New adjusted rank: ${newRank.toFixed(3)} (moved ${splitWeight * 100}% of the way from ${currentRank} to ${targetRank + 1})`); // Log target rank + 1 for clarity
                                    } else {
                                        logDebug(`⚠️ Skipping adjustment because ${teamB.name} already has adjusted rank: ${teamB.adjustedRank} (original: ${j+1})`);
                                    }
                                } // End of hasReciprocalLoss check
                                // Handle non-split 5-set wins (removed as this logic is now in apply5SetMatchAdjustments)
                            } // End of check for 5-set win
                        } // End of inner loop (team B)
                    } // End of outer loop (team A)

                    logDebug(`Completed 5-set match adjustments within calculateAdjustedRankings. Total adjustments made: ${fiveSetAdjustmentsCount}`);
                } else { // <-- ADDED ELSE BLOCK
                    logDebug(`Skipping 5-set match win adjustments in calculateAdjustedRankings as enableFiveSet is false.`);
                } // <-- END OF GUARD

                // Re-sort by rating to maintain original order before display (if needed elsewhere)
                // rankings.sort((a, b) => b.rating - a.rating); // Keep commented out as sorting happens later
            }

            // Helper function to find all 5-set match wins
            function findFiveSetMatchWins(matches) {
                const fiveSetWins = {};
                let totalFiveSetMatches = 0;
                
                // Check for valid matches array
                if (!matches || matches.length === 0) {
                    logDebug("WARNING: No matches provided to findFiveSetMatchWins function");
                    if (globalMatches && globalMatches.length > 0) {
                        logDebug(`Using globalMatches instead (${globalMatches.length} matches)`);
                        matches = globalMatches;
                    } else {
                        logDebug("No fallback matches available either. No 5-set win adjustments will be made.");
                        return fiveSetWins;
                    }
                }
                
                logDebug(`Looking for 5-set match wins in ${matches.length} matches...`);
                
                matches.forEach(match => {
                    // Only process matches with format 5 (best of 5)
                    if (match.format === 5) {
                        totalFiveSetMatches++;
                        
                        // Process Team A wins
                        if (match.teamASets > match.teamBSets) {
                            if (!fiveSetWins[match.teamA]) {
                                fiveSetWins[match.teamA] = [];
                            }
                            fiveSetWins[match.teamA].push(match.teamB);
                            logDebug(`Found 5-set win: ${match.teamA} beat ${match.teamB} (${match.teamASets}-${match.teamBSets})`);
                        }
                        // Process Team B wins
                        else if (match.teamBSets > match.teamASets) {
                            if (!fiveSetWins[match.teamB]) {
                                fiveSetWins[match.teamB] = [];
                            }
                            fiveSetWins[match.teamB].push(match.teamA);
                            logDebug(`Found 5-set win: ${match.teamB} beat ${match.teamA} (${match.teamBSets}-${match.teamASets})`);
                        }
                    }
                });
                
                // Log summary of 5-set match wins
                const teamsWithFiveSetWins = Object.keys(fiveSetWins);
                logDebug(`Total 5-set matches found: ${totalFiveSetMatches}`);
                logDebug(`Teams with 5-set wins (${teamsWithFiveSetWins.length}): ${teamsWithFiveSetWins.join(', ') || 'None'}`);
                
                // Log detailed breakdown of each team's 5-set wins
                teamsWithFiveSetWins.forEach(team => {
                    logDebug(`${team} has 5-set wins over: ${fiveSetWins[team].join(', ')}`);
                });
                
                return fiveSetWins;
            }

            // *** NEW HELPER FUNCTION ***
            // Helper function to check if teamA has a recorded 5-set win over teamB
            function hasBo5Win(teamA, teamB) {
                // Ensure fiveSetWins is accessible (it should be calculated before this is called)
                // If fiveSetWins isn't global, this might need adjustment based on scope
                // Assuming fiveSetWins is populated similarly to how it's used in applyBestOf3MatchAdjustments
                const fiveSetWinsData = findFiveSetMatchWins(globalMatches || []); // Recalculate or use stored data
                
                return fiveSetWinsData[teamA] && fiveSetWinsData[teamA].includes(teamB);
            }

            // Helper function to find all 5-set match losses
            function findFiveSetMatchLosses(matches) {
                const fiveSetLosses = {};
                
                // Check for valid matches array
                if (!matches || matches.length === 0) {
                    logDebug("WARNING: No matches provided to findFiveSetMatchLosses function");
                    if (globalMatches && globalMatches.length > 0) {
                        matches = globalMatches;
                    } else {
                        return fiveSetLosses;
                    }
                }
                
                matches.forEach(match => {
                    // Only process matches with format 5 (best of 5)
                    if (match.format === 5) {
                        // Process Team A losses
                        if (match.teamASets < match.teamBSets) {
                            if (!fiveSetLosses[match.teamA]) {
                                fiveSetLosses[match.teamA] = [];
                            }
                            fiveSetLosses[match.teamA].push(match.teamB);
                            logDebug(`Found 5-set loss: ${match.teamA} lost to ${match.teamB} (${match.teamASets}-${match.teamBSets})`);
                        }
                        // Process Team B losses
                        else if (match.teamBSets < match.teamASets) {
                            if (!fiveSetLosses[match.teamB]) {
                                fiveSetLosses[match.teamB] = [];
                            }
                            fiveSetLosses[match.teamB].push(match.teamA);
                            logDebug(`Found 5-set loss: ${match.teamB} lost to ${match.teamA} (${match.teamBSets}-${match.teamASets})`);
                        }
                    }
                });
                
                return fiveSetLosses;
            }

            // Helper function to check if there's a circular dependency
            function hasCircularDependency(teamA, teamB, teamWins) {
                // Create a map for 5-set match wins only
                const fiveSetWins = {};
                
                // Only consider 5-set matches for circular dependency checks
                if (globalMatches && globalMatches.length > 0) {
                    for (const match of globalMatches) {
                        // Only process matches with format 5 (best of 5)
                        if (match.format === 5) {
                            // Process Team A wins
                            if (match.teamASets > match.teamBSets) {
                                if (!fiveSetWins[match.teamA]) {
                                    fiveSetWins[match.teamA] = [];
                                }
                                fiveSetWins[match.teamA].push(match.teamB);
                            }
                            // Process Team B wins
                            else if (match.teamBSets > match.teamASets) {
                                if (!fiveSetWins[match.teamB]) {
                                    fiveSetWins[match.teamB] = [];
                                }
                                fiveSetWins[match.teamB].push(match.teamA);
                            }
                        }
                    }
                }
                
                // Check if Team B beat Team A in a 5-set match. If not, no need to check further
                if (!fiveSetWins[teamB] || !fiveSetWins[teamB].includes(teamA)) {
                    return false;
                }
                
                // We need to check if there's any team C such that:
                // A beat C and C beat B in 5-set matches, creating a circular dependency
                const teamsBeatenByA = fiveSetWins[teamA] || [];
                
                for (const teamC of teamsBeatenByA) {
                    if (fiveSetWins[teamC] && fiveSetWins[teamC].includes(teamB)) {
                        // Found a circular dependency in 5-set matches: A beat C, C beat B, and B beat A
                        logDebug(`5-set circular dependency found: ${teamA} beat ${teamC}, ${teamC} beat ${teamB}, ${teamB} beat ${teamA}`);
                        return true;
                    }
                }
                
                return false;
            }

            // Helper function to find all Best-of-3 match wins
            function findBestOf3MatchWins(matches) {
                const bestOf3Wins = {};
                let totalBestOf3Matches = 0;
                
                if (!matches || matches.length === 0) {
                    logDebug("WARNING: No matches provided to findBestOf3MatchWins");
                    return bestOf3Wins;
                }
                
                logDebug(`Looking for Best-of-3 match wins (format 3) in ${matches.length} matches...`);
                
                matches.forEach(match => {
                    // Only process matches with format 3 (best of 3: 2-0 or 2-1)
                    if (match.format === 3) {
                        totalBestOf3Matches++;
                        
                        // Process Team A wins
                        if (match.teamASets > match.teamBSets) {
                            if (!bestOf3Wins[match.teamA]) {
                                bestOf3Wins[match.teamA] = [];
                            }
                            bestOf3Wins[match.teamA].push(match.teamB);
                            logDebug(`Found Best-of-3 win: ${match.teamA} beat ${match.teamB} (${match.teamASets}-${match.teamBSets})`);
                        }
                        // Process Team B wins
                        else if (match.teamBSets > match.teamASets) {
                            if (!bestOf3Wins[match.teamB]) {
                                bestOf3Wins[match.teamB] = [];
                            }
                            bestOf3Wins[match.teamB].push(match.teamA);
                            logDebug(`Found Best-of-3 win: ${match.teamB} beat ${match.teamA} (${match.teamBSets}-${match.teamASets})`);
                        }
                    }
                });
                
                const teamsWithWins = Object.keys(bestOf3Wins);
                logDebug(`Total Best-of-3 matches found: ${totalBestOf3Matches}`);
                logDebug(`Teams with Best-of-3 wins (${teamsWithWins.length}): ${teamsWithWins.join(', ') || 'None'}`);
                
                return bestOf3Wins;
            }

            // Helper function to check if there's a circular dependency using combined wins
            function hasCircularDependencyCombined(teamA, teamB, combinedWins) {
                // Check if Team B beat Team A in any format (Bo5 or Bo3)
                if (!combinedWins[teamB] || !combinedWins[teamB].includes(teamA)) {
                    return false;
                }
                
                // Check if there's any team C such that:
                // A beat C (any format) AND C beat B (any format)
                const teamsBeatenByA = combinedWins[teamA] || [];
                
                for (const teamC of teamsBeatenByA) {
                    if (combinedWins[teamC] && combinedWins[teamC].includes(teamB)) {
                        logDebug(`Combined Circular dependency found: ${teamA} beat ${teamC}, ${teamC} beat ${teamB}, and ${teamB} beat ${teamA}`);
                        return true;
                    }
                }
                
                return false;
            }
                    
            function calculateVolleyballRankings(teams, teamToIndex, matches, weightFactors) {
                const numTeams = teams.length;
                
                logDebug(`Building Colley matrix for ${numTeams} teams...`);
                
                // Initialize the Colley matrix (n×n matrix where n is the number of teams)
                const A = Array(numTeams + 1).fill().map(() => Array(numTeams + 1).fill(0));
                
                // Initialize the b vector (right-hand side of the equation Ax=b)
                const b = Array(numTeams + 1).fill(0);
                
                // Count weighted wins and losses for each team
                const wins = Array(numTeams + 1).fill(0);
                const losses = Array(numTeams + 1).fill(0);
                const totalGames = Array(numTeams + 1).fill(0);
                
                // Process each match with weights
                matches.forEach(match => {
                    const teamAIndex = teamToIndex[match.teamA];
                    const teamBIndex = teamToIndex[match.teamB];
                    let baseWeight = weightFactors[match.format] || 0.5; // Default to 0.5 if format is unknown
                    
                    // Calculate set differential bonus
                    let setDiffBonus = 0;
                    if (match.teamASets > match.teamBSets) {
                        // Team A won - calculate bonus based on set differential
                        const setDiff = match.teamASets - match.teamBSets;
                        setDiffBonus = setDiff * 0.1; // 0.1 bonus per set difference
                    } else if (match.teamBSets > match.teamASets) {
                        // Team B won - calculate bonus based on set differential
                        const setDiff = match.teamBSets - match.teamASets;
                        setDiffBonus = setDiff * 0.1; // 0.1 bonus per set difference
                    }
                    
                    // Apply the set differential bonus to the weight
                    const weight = baseWeight * (1 + setDiffBonus);
                    
                    // Update Colley matrix based on the matchup
                    A[teamAIndex][teamAIndex] += weight;
                    A[teamBIndex][teamBIndex] += weight;
                    A[teamAIndex][teamBIndex] -= weight;
                    A[teamBIndex][teamAIndex] -= weight;
                    
                    // Determine winner based on sets
                    if (match.teamASets > match.teamBSets) {
                        // Team A won
                        wins[teamAIndex] += weight;
                        losses[teamBIndex] += weight;
                    } else if (match.teamBSets > match.teamASets) {
                        // Team B won
                        wins[teamBIndex] += weight;
                        losses[teamAIndex] += weight;
                    } else {
                        // Tie - split the weight between both teams
                        wins[teamAIndex] += weight * 0.5;
                        wins[teamBIndex] += weight * 0.5;
                        losses[teamAIndex] += weight * 0.5;
                        losses[teamBIndex] += weight * 0.5;
                    }
                    
                    // Update total games counter
                    totalGames[teamAIndex] += weight;
                    totalGames[teamBIndex] += weight;
                });
                
                // Complete the Colley matrix and b vector
                for (let i = 1; i <= numTeams; i++) {
                    if (totalGames[i] > 0) {  // Only include teams that played games
                        A[i][i] = 2 + totalGames[i];
                        b[i] = 1 + (wins[i] - losses[i]) / 2;
                    } else {
                        // For teams with no games, set diagonal to 1 and b to 0.5
                        A[i][i] = 1;
                        b[i] = 0.5;
                    }
                }
                
                logDebug(`Solving linear system of equations...`);
                
                // Solve the linear system Ax = b using Gaussian elimination
                const x = solveLinearSystem(A, b, numTeams);
                
                // Create array of teams with their ratings
                const teamRatings = [];
                for (let i = 1; i <= numTeams; i++) {
                    teamRatings.push({
                        name: teams[i-1], // Convert back from 1-based to 0-based index
                        rating: x[i]
                    });
                }
                
                // Sort by rating in descending order
                teamRatings.sort((a, b) => b.rating - a.rating);
                
                return teamRatings;
            }
            
            function calculateScheduleStrength(rankings, opponentRatings, teamToIndex) {
                // Create a map for easier lookup of team ratings and ranks
                const ratingMap = {};
                const adjustedRatingMap = {};
                const rankMap = {};
                
                rankings.forEach((team, index) => {
                    ratingMap[team.name] = team.rating;
                    adjustedRatingMap[team.name] = team.adjustedRating !== undefined ? team.adjustedRating : team.rating;
                    rankMap[team.name] = index + 1; // Store 1-based rank
                });
                
                // Calculate schedule strength for each team
                rankings.forEach(team => {
                    const opponents = opponentRatings[team.name];
                    if (opponents && opponents.length > 0) {
                        // Create array of opponents with their ratings and ranks
                        const opponentsWithRatings = [];
                        let teamsWithRatings = 0;
                        
                        opponents.forEach(opponent => {
                            // Use adjusted ratings instead of normal ratings
                            if (adjustedRatingMap[opponent]) {
                                opponentsWithRatings.push({
                                    name: opponent,
                                    rating: adjustedRatingMap[opponent], // Use adjusted rating
                                    rank: rankMap[opponent]
                                });
                                teamsWithRatings++;
                            }
                        });
                        
                        // Sort opponents by rating (highest to lowest)
                        opponentsWithRatings.sort((a, b) => b.rating - a.rating);
                        
                        let weightedSum = 0;
                        let totalWeight = 0;
                        
                        // Calculate weighted average of opponent ratings
                        if (teamsWithRatings > 0) {
                            opponentsWithRatings.forEach((opponent, index) => {
                                // Calculate weight - higher for top teams, decaying for lower teams
                                let weight;
                                if (index < 5) {
                                    // Top 5 teams get weights of 7, 6, 5, 4, and 3
                                    weight = 7 - index;
                                } else {
                                    // Teams after the top 5 get exponentially decreasing weights
                                    weight = 3 * Math.exp(-0.5 * (index - 4));
                                }
                                
                                weightedSum += opponent.rating * weight;
                                totalWeight += weight;
                            });
                            
                            // Store the weighted schedule strength
                            team.scheduleStrength = totalWeight > 0 ? weightedSum / totalWeight : 0;
                            
                            // Store the top 5 opponents for tooltip display
                            team.topOpponents = opponentsWithRatings.slice(0, 5).map(o => o.name).join(', ');
                    } else {
                        team.scheduleStrength = 0;
                            team.topOpponents = '';
                        }
                    } else {
                        team.scheduleStrength = 0;
                        team.topOpponents = '';
                    }
                });
            }
            
            function solveLinearSystem(A, b, n) {
                // Create augmented matrix [A|b]
                const aug = Array(n + 1).fill().map((_, i) => [...A[i], b[i]]);
                
                // Forward elimination
                for (let i = 1; i <= n; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let j = i + 1; j <= n; j++) {
                        if (Math.abs(aug[j][i]) > Math.abs(aug[maxRow][i])) {
                            maxRow = j;
                        }
                    }
                    
                    // Swap rows
                    if (maxRow !== i) {
                        [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                    }
                    
                    // Skip if pivot is zero (singular matrix)
                    if (Math.abs(aug[i][i]) < 1e-10) continue;
                    
                    // Eliminate below
                    for (let j = i + 1; j <= n; j++) {
                        const factor = aug[j][i] / aug[i][i];
                        for (let k = i; k <= n + 1; k++) {
                            aug[j][k] -= factor * aug[i][k];
                        }
                    }
                }
                
                // Back substitution
                const x = Array(n + 1).fill(0);
                for (let i = n; i >= 1; i--) {
                    // Skip if pivot is zero
                    if (Math.abs(aug[i][i]) < 1e-10) {
                        x[i] = 0.5; // Default value for undetermined variables
                        continue;
                    }
                    
                    x[i] = aug[i][n + 1];
                    for (let j = i + 1; j <= n; j++) {
                        x[i] -= aug[i][j] * x[j];
                    }
                    x[i] /= aug[i][i];
                }
                
                return x;
            }
            
            function displayRankings(rankings, teamWins = {}, existingTeamMap = null, matches = []) {
    const tableBody = document.querySelector('#rankings-table tbody');
    tableBody.innerHTML = '';
    
    logDebug(`Displaying ${rankings.length} team rankings with wins`);
                
                // Check if any hypothetical matches are being used and update the heading
                const rankingsHeading = document.querySelector('#results h2');
                if (rankingsHeading && hypotheticalMatches.length > 0) {
                    // Change the heading to indicate hypothetical rankings
                    rankingsHeading.textContent = 'Rankings (Hypothetical)';
                    
                    // Create or update the hypothetical match note
                    let noteElement = document.querySelector('#hypothetical-match-note');
                    if (!noteElement) {
                        noteElement = document.createElement('p');
                        noteElement.id = 'hypothetical-match-note';
                        noteElement.className = 'hypothetical-note';
                        // Insert the note right after the heading
                        rankingsHeading.insertAdjacentElement('afterend', noteElement);
                    }
                    
                    // Create note text with details of all hypothetical matches
                    let noteText = 'Applied Hypothetical Match(es): ';
                    hypotheticalMatches.forEach((match, index) => {
                        if (index > 0) {
                            noteText += ' | ';
                        }
                        noteText += `${match.teamA} ${match.teamASets} - ${match.teamBSets} ${match.teamB}`;
                    });
                    noteElement.textContent = noteText;
                } else if (rankingsHeading) {
                    // Reset heading to normal if there are no hypothetical matches
                    rankingsHeading.textContent = 'Rankings';
                    
                    // Remove any existing hypothetical match note
                    const noteElement = document.querySelector('#hypothetical-match-note');
                    if (noteElement) {
                        noteElement.remove();
                    }
                }
                
                // Add last update info if available
                let updateElement = document.querySelector('#last-update-info');
                if (lastUpdateInfo) {
                    if (!updateElement) {
                        updateElement = document.createElement('p');
                        updateElement.id = 'last-update-info';
                        updateElement.className = 'update-info';
                        // Insert right after heading or hypothetical note
                        const noteElement = document.querySelector('#hypothetical-match-note');
                        if (noteElement) {
                            noteElement.insertAdjacentElement('afterend', updateElement);
                        } else if (rankingsHeading) {
                            rankingsHeading.insertAdjacentElement('afterend', updateElement);
                        }
                    }
                    // Calculate days since last update
                    let daysAgoText = "";
                    if (lastUpdateInfo) {
                        try {
                            const updateDate = new Date(lastUpdateInfo);
                            if (!isNaN(updateDate.getTime())) { // Valid date
                                const today = new Date();
                                today.setHours(0, 0, 0, 0); // Set to beginning of day
                                updateDate.setHours(0, 0, 0, 0); // Set to beginning of day
                                
                                const diffTime = today.getTime() - updateDate.getTime();
                                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                                
                                if (diffDays === 0) {
                                    daysAgoText = " <strong>(Today)</strong>";
                                } else if (diffDays === 1) {
                                    daysAgoText = " <strong>(1 Day Ago)</strong>";
                                } else {
                                    daysAgoText = ` <strong>(${diffDays} Days Ago)</strong>`;
                                }
                            }
                        } catch (e) {
                            console.error("Error calculating days since update:", e);
                        }
                    }
                    updateElement.innerHTML = `Last Refreshed MaxPreps Data: ${lastUpdateInfo}${daysAgoText}`;
                } else if (updateElement) {
                    // If no update info but element exists, remove it
                    updateElement.remove();
                }
    
    // Check for any 5-set adjusted teams
    const teamsAdjustedForFiveSet = rankings.filter(team => team.adjustedDueToFiveSet);
    if (teamsAdjustedForFiveSet.length > 0) {
        logDebug(`Found ${teamsAdjustedForFiveSet.length} teams adjusted due to 5-set wins:`);
        teamsAdjustedForFiveSet.forEach(team => {
            logDebug(`  ${team.name} (adjusted rank: ${team.adjustedRank}) - beat ${team.beatInFiveSet} in a 5-set match`);
        });
    } else {
        logDebug(`No teams found with 5-set match win adjustments`);
    }
    
    // Check for any undefeated adjusted teams
    const undefeatedAdjustedTeams = rankings.filter(team => team.adjustedDueToUndefeated);
    if (undefeatedAdjustedTeams.length > 0) {
        logDebug(`Found ${undefeatedAdjustedTeams.length} undefeated teams with adjustments:`);
        undefeatedAdjustedTeams.forEach(team => {
            logDebug(`  ${team.name} (adjusted rank: ${team.adjustedRank}) - undefeated, best win over: ${team.bestBeatenTeam}`);
        });
    } else {
        logDebug(`No undefeated teams found with rank adjustments`);
    }
    
    // Get team map from parameter or create if not provided
    const teamMap = existingTeamMap || {};
    if (!existingTeamMap) {
        rankings.forEach(team => {
            teamMap[team.name] = team;
        });
        if (currentWinlessTeams) {
            currentWinlessTeams.forEach(team => {
                teamMap[team.name] = team;
            });
        }
    }
    
    // Use teamWins parameter with fallback
    const wins = teamWins || {};
    
    // Use matches parameter or global matches
    const matchData = matches || globalMatches || [];
    
    // Collect all teams by league to create standings data
    const leagueTeams = {};
    
    // First pass: collect teams with league info from rankings
    for (const teamName in teamMap) {
        const team = teamMap[teamName];
        if (team.league) {
            if (!leagueTeams[team.league]) {
                leagueTeams[team.league] = [];
            }
            leagueTeams[team.league].push(team);
        }
    }
    
    // Sort teams within each league by their league rank
    for (const league in leagueTeams) {
        leagueTeams[league].sort((a, b) => {
            // First, sort by league rank if available
            if (a.leagueRank !== undefined && b.leagueRank !== undefined) {
                return a.leagueRank - b.leagueRank;
            }
            // Otherwise, sort alphabetically
            else if (a.name && b.name) {
                return a.name.localeCompare(b.name);
            }
            return 0;
        });
    }
    
    rankings.forEach((team, index) => {
        const row = document.createElement('tr');
        
        const rankCell = document.createElement('td');
        rankCell.className = 'rank-column';
                    
                    // For rating, str, and adj columns:
                    // - When showing highest to lowest (desc): 1, 2, 3...
                    // - When showing lowest to highest (asc): n, n-1, n-2...
                    
                    if ((sortState.column === 'rating' || sortState.column === 'str' || sortState.column === 'adj') && 
                        sortState.direction === 'asc') {
                        // For these columns in ascending order (lowest first), show reverse ranks
                        rankCell.textContent = rankings.length - index;
                    } else {
                        // Default: show sequential ranks
        rankCell.textContent = index + 1;
                    }
                    
        row.appendChild(rankCell);
        
        const nameCell = document.createElement('td');
        
        // --- Link Generation Logic --- 
        let teamPath = globalTeamPaths[team.name];
        if (!teamPath) {
            // try again with just the abbreviation part
            const shortName = team.name.replace(/\s*\\(.+\\)\\s*$/, '').trim();
            teamPath = globalTeamPaths[shortName];
            if (teamPath) {
                logDebug(`Rankings: Found path for ${team.name} using fallback short name ${shortName}`);
            }
        }
        let maxPrepsUrl = getMaxPrepsUrl(teamPath); // Use helper function

        // Create link or use cell as container
        let nameContainer;
        if (maxPrepsUrl) {
            const link = document.createElement('a');
            link.href = maxPrepsUrl;
            link.target = '_blank';
            link.style.textDecoration = 'none'; // Keep link look consistent
            link.style.color = 'inherit';
            nameContainer = link; // Spans will be appended to the link
        } else {
            nameContainer = document.createElement('span'); // Use a span if no link
        }

        // --- Append Name, Record, League Rank --- 
        const nameSpan = document.createElement('span');
        nameSpan.textContent = team.name + ' (';
        nameContainer.appendChild(nameSpan);

        // Add hoverable wins count
        if (team.record) {
            // Create span for wins with tooltip
            const winsSpan = document.createElement('span');
            winsSpan.className = 'record-hover';
            winsSpan.textContent = team.record.wins;
            
            // Get the list of opponents this team has beaten
            const opponents = wins[team.name] || [];
            
            // Sort opponents by their rating (highest first)
            const sortedOpponents = [...opponents].sort((a, b) => {
                const ratingA = teamMap[a]?.rating || 0;
                const ratingB = teamMap[b]?.rating || 0;
                return ratingB - ratingA;
            });
            
            // Create tooltip content with all wins
            if (sortedOpponents.length > 0) {
                let tooltipContent = `${team.name}'s Wins (in order of opponent str):\n`;
                
                sortedOpponents.forEach((opponent, i) => {
                    const opponentRating = teamMap[opponent]?.rating || 0;
                    
                    // Get all matches between these teams
                    const matchResults = findMatchResult(matches, team.name, opponent);
                    let resultText = matchResults ? ` ${matchResults}` : '';
                    
                    tooltipContent += `${i+1}. ${opponent} (${opponentRating.toFixed(3)})${resultText}\n`;
                });
                
                // Store tooltip content
                winsSpan.dataset.tooltip = tooltipContent;
                
                // Add event listeners for showing/hiding tooltip
                winsSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                winsSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
            }
            
            nameContainer.appendChild(winsSpan);
            
            // Add hyphen
            const hyphenSpan = document.createElement('span');
            hyphenSpan.textContent = '-';
            nameContainer.appendChild(hyphenSpan);
            
            // Create span for losses with tooltip
            const lossesSpan = document.createElement('span');
            lossesSpan.className = 'record-hover';
            lossesSpan.textContent = team.record.losses;
            
            // Get the list of opponents who have beaten this team
            const losesToOpponents = [];
            for (const opponent in wins) {
                if (wins[opponent] && wins[opponent].includes(team.name)) {
                    losesToOpponents.push(opponent);
                }
            }
            
            // Sort opponents by their rating (highest first)
            const sortedLossOpponents = [...losesToOpponents].sort((a, b) => {
                const ratingA = teamMap[a]?.rating || 0;
                const ratingB = teamMap[b]?.rating || 0;
                return ratingB - ratingA;
            });
            
            // Create tooltip content with all losses
            if (sortedLossOpponents.length > 0) {
                let tooltipContent = `${team.name}'s Losses (in order of opponent str):\n`;
                
                sortedLossOpponents.forEach((opponent, i) => {
                    const opponentRating = teamMap[opponent]?.rating || 0;
                    
                    // Get all matches between these teams
                    const matchResults = findMatchResult(matches, team.name, opponent);
                    let resultText = matchResults ? ` ${matchResults}` : '';
                    
                    tooltipContent += `${i+1}. ${opponent} (${opponentRating.toFixed(3)})${resultText}\n`;
                });
                
                // Store tooltip content
                lossesSpan.dataset.tooltip = tooltipContent;
                
                // Add event listeners for showing/hiding tooltip
                lossesSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                lossesSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
            }
            
            nameContainer.appendChild(lossesSpan);
            
            // Add ties if needed, with hover tooltip
            if (team.record.ties > 0) {
                // Add hyphen
                const hyphenSpan = document.createElement('span');
                hyphenSpan.textContent = '-';
                nameContainer.appendChild(hyphenSpan);
                
                // Create span for ties with tooltip
                const tiesSpan = document.createElement('span');
                tiesSpan.className = 'record-hover';
                tiesSpan.textContent = team.record.ties;
                
                // Find all tied matches for this team
                const tiedMatches = [];
                for (const match of matchData) {
                    if ((match.teamA === team.name || match.teamB === team.name) && 
                        match.teamASets === match.teamBSets) {
                        tiedMatches.push(match);
                    }
                }
                
                // Get all opponents this team tied with
                const tiedOpponents = tiedMatches.map(match => 
                    match.teamA === team.name ? match.teamB : match.teamA
                );
                
                // Sort opponents by their rating (highest first)
                const sortedTiedOpponents = [...new Set(tiedOpponents)].sort((a, b) => {
                    const ratingA = teamMap[a]?.rating || 0;
                    const ratingB = teamMap[b]?.rating || 0;
                    return ratingB - ratingA;
                });
                
                // Create tooltip content with all ties
                if (sortedTiedOpponents.length > 0) {
                    let tooltipContent = `${team.name}'s Ties (in order of opponent str):\n`;
                    
                    sortedTiedOpponents.forEach((opponent, i) => {
                        const opponentRating = teamMap[opponent]?.rating || 0;
                        
                        // Get all matches between these teams
                        const matchResults = findMatchResult(matches, team.name, opponent);
                        let resultText = matchResults ? ` ${matchResults}` : '';
                        
                        tooltipContent += `${i+1}. ${opponent} (${opponentRating.toFixed(3)})${resultText}\n`;
                    });
                    
                    // Store tooltip content
                    tiesSpan.dataset.tooltip = tooltipContent;
                    
                    // Add event listeners for showing/hiding tooltip
                    tiesSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                    tiesSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                }
                
                nameContainer.appendChild(tiesSpan);
            }
            
            // Close parenthesis
            const closeParen = document.createElement('span');
            closeParen.textContent = ')';
            nameContainer.appendChild(closeParen);
        } else {
            // If no record, just show (0-0)
            const recordText = document.createElement('span');
            recordText.textContent = '0-0)';
            nameContainer.appendChild(recordText);
        }
        
        // Add league rank with hover (existing functionality)
        if (team.league) {
            // Create a span for the league rank
            const leagueRankSpan = document.createElement('span');
            leagueRankSpan.className = 'league-rank';
            
            // Format as "- 1st" or "- 1st (Tie)" or just "- League" if no rank
            let rankText = ' - ';
            
            if (team.leagueRank !== undefined) {
                const rankSuffix = getOrdinalSuffix(team.leagueRank);
                rankText += `${team.leagueRank}${rankSuffix}`;
                
                if (team.leagueIsTied) {
                    rankText += " (Tie)";
                }
            } else {
                // Just show league name indicator if no rank
                rankText += "League";
            }
            
            leagueRankSpan.textContent = rankText;
            
            // Create tooltip content with all teams in the league
            let tooltipContent = `${team.league} League Standings (Best-of-5 Matches Only):\n`;
            
            if (leagueTeams[team.league]) {
                leagueTeams[team.league].forEach((leagueTeam, leagueIndex) => {
                    let rankText = leagueTeam.leagueRank !== undefined 
                        ? `${leagueTeam.leagueRank}${getOrdinalSuffix(leagueTeam.leagueRank)} - ` 
                        : "-";
                        
                        const isTiedText = leagueTeam.leagueIsTied ? " (Tie)" : "";
                        
                        // Format league record, defaulting to 0-0 if no record
                        let leagueRecordText = "";
                        if (leagueTeam.leagueRecord) {
                            leagueRecordText = ` (${leagueTeam.leagueRecord.wins}-${leagueTeam.leagueRecord.losses}`;
                            if (leagueTeam.leagueRecord.ties > 0) {
                                leagueRecordText += `-${leagueTeam.leagueRecord.ties}`;
                            }
                            
                            // Add set differential if available
                            if (leagueTeam.setDifferential !== undefined) {
                                const setDiffSymbol = leagueTeam.setDifferential > 0 ? '+' : '';
                                leagueRecordText += `, SD: ${setDiffSymbol}${leagueTeam.setDifferential}`;
                            }
                            
                            // Add head-to-head info if applicable
                            if (leagueTeam.headToHead) {
                                // Find teams with same win percentage
                                const currTeamWinPct = (leagueTeam.leagueRecord.wins / 
                                    (leagueTeam.leagueRecord.wins + leagueTeam.leagueRecord.losses + leagueTeam.leagueRecord.ties) || 0).toFixed(3);
                                    
                                // Check for head-to-head wins that affected placement
                                const h2hInfo = [];
                                
                                // Check each team in the same league
                                leagueTeams[leagueTeam.league].forEach(otherTeam => {
                                    if (otherTeam.name !== leagueTeam.name && otherTeam.leagueRecord) {
                                        // Calculate other team's win percentage
                                        const otherTeamWinPct = (otherTeam.leagueRecord.wins / 
                                            (otherTeam.leagueRecord.wins + otherTeam.leagueRecord.losses + otherTeam.leagueRecord.ties) || 0).toFixed(3);
                                        
                                        // If win percentages are equal
                                        if (currTeamWinPct === otherTeamWinPct) {
                                            // Check if they played each other
                                            const h2h = leagueTeam.headToHead[otherTeam.name];
                                            if (h2h && h2h.wins + h2h.losses > 0) {
                                                h2hInfo.push(`${h2h.wins}-${h2h.losses} vs ${otherTeam.name}`);
                                            }
                                        }
                                    }
                                });
                                
                                if (h2hInfo.length > 0) {
                                    leagueRecordText += `, H2H: ${h2hInfo.join(', ')}`;
                                }
                            }
                            
                            leagueRecordText += `)`;
                        } else {
                            leagueRecordText = " (0-0)";
                        }
                        
                        // Highlight the current team
                        if (leagueTeam.name === team.name) {
                            tooltipContent += `→ ${rankText}${isTiedText}: ${leagueTeam.name}${leagueRecordText}\n`;
                        } else {
                            tooltipContent += `  ${rankText}${isTiedText}: ${leagueTeam.name}${leagueRecordText}\n`;
                        }
                });
            }
            
            // Store tooltip content as a data attribute
            leagueRankSpan.dataset.tooltip = tooltipContent;
            
            // Add event listeners for showing/hiding tooltip
            leagueRankSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
            leagueRankSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
            
            // Append the league rank span to the name cell
            nameContainer.appendChild(leagueRankSpan);
        }
        
        // Append the container (link or span) to the cell
        nameCell.appendChild(nameContainer); 
        row.appendChild(nameCell);
        
        // Add rating
        const ratingCell = document.createElement('td');
        if (typeof team.rating === 'number') {
            // Show rating with blended score in tooltip
        ratingCell.textContent = team.rating.toFixed(3);
            
            // Add a tooltip with the blended score if available
            if (team.blendedScore !== undefined) {
                ratingCell.title = `Rating: ${team.rating.toFixed(3)}, Blended with SOS: ${team.blendedScore.toFixed(3)}`;
            }
        } else {
            ratingCell.textContent = 'N/A';
        }
        row.appendChild(ratingCell);
        
        // Create the strength cell with tooltip showing weighted calculation
        const strengthCell = document.createElement('td');
        
        // Always create a span for the strength value that can have a tooltip
        const strengthValueSpan = document.createElement('span');
        strengthValueSpan.textContent = team.scheduleStrength ? team.scheduleStrength.toFixed(3) : 'N/A';
        strengthValueSpan.className = 'record-hover'; // Add hover class for tooltip
        
        if (team.scheduleStrength) {
            // Prepare tooltip text explaining the weighted calculation
            let tooltipText = `Top Opponents:\n${team.topOpponents || 'None'}\n`;
        
            // Add tooltip functionality
            strengthValueSpan.dataset.tooltip = tooltipText;
            strengthValueSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
            strengthValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
        }
        
        // Add the span to the cell
        strengthCell.appendChild(strengthValueSpan);
        row.appendChild(strengthCell);
        
        // Show the adjusted rating with appropriate indicators in the Adj column
        const adjRankCell = document.createElement('td');
        
        // Only show adjusted ratings when sorting by Adj column
        if (sortState.column === 'adj') {
            // If we have an adjusted rating, use it
            if (team.adjustedRating !== undefined) {
                let displayValue = team.adjustedRating.toFixed(3);
                
                // Add indicators for special cases
                if (team.adjustedDueToUndefeated) {
                    // Create a span for the adjusted rating value that can have a tooltip
                    const adjValueSpan = document.createElement('span');
                    adjValueSpan.textContent = displayValue;
                    adjValueSpan.className = 'record-hover'; // Add hover class for tooltip
                    
                    adjRankCell.classList.add('adj-needs-adjustment');
                    
                    // Prepare tooltip text
                    const tooltipText = team.bestBeatenTeam 
                        ? `Undefeated team ranked right above their highest win over ${team.bestBeatenTeam}`
                        : 'Undefeated team ranked right above their highest win';
                    
                    // Add tooltip functionality
                    adjValueSpan.dataset.tooltip = tooltipText;
                    adjValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                    adjValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                    
                    // Add the span to the cell
                    adjRankCell.appendChild(adjValueSpan);
                }
                // Show different handling for teams exempted from adjustment due to having 15+ wins
                else if (team.exemptedFromAdjustment) {
                    // Create a span for the adjusted rating value that can have a tooltip
                    const adjValueSpan = document.createElement('span');
                    adjValueSpan.textContent = displayValue;
                    adjValueSpan.className = 'record-hover exempted-team-span'; // Add specific class for exempted teams
                    
                    // Add red color for exempted teams
                    adjRankCell.classList.add('adj-needs-adjustment');
                    adjRankCell.style.color = '#cc0000'; // Explicitly set red color
                    
                    // Prepare tooltip text
                    const tooltipText = `Undefeated team with ${team.record.wins} wins (≥ 15) exempted from downward adjustment`;
                    
                    // Add tooltip functionality
                    adjValueSpan.dataset.tooltip = tooltipText;
                    adjValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                    adjValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                    
                    // Add the span to the cell
                    adjRankCell.appendChild(adjValueSpan);
                }
                // Show indicator for teams adjusted due to 5-set match wins
                else if (team.adjustedDueToFiveSet) {
                    // Create a span for the adjusted rating value that can have a tooltip
                    const adjValueSpan = document.createElement('span');
                    adjValueSpan.textContent = displayValue;
                    adjValueSpan.className = 'record-hover'; // Add hover class for tooltip
                    
                    adjRankCell.classList.add('adj-five-set-win');
                    
                    // Prepare tooltip text
                    const tooltipText = `Adjusted higher due to 5-set match win over ${team.beatInFiveSet}`;
                    
                    // Add tooltip functionality
                    adjValueSpan.dataset.tooltip = tooltipText;
                    adjValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                    adjValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                    
                    // Add the span to the cell
                    adjRankCell.appendChild(adjValueSpan);
                }
                // Show indicator for teams adjusted due to league position
                else if (team.adjustedDueToLeague) {
                    // Create a span for the adjusted rating value that can have a tooltip
                    const adjValueSpan = document.createElement('span');
                    adjValueSpan.textContent = displayValue;
                    adjValueSpan.className = 'record-hover league-adj-span'; // Add specific class for league adjustment
                    
                    adjRankCell.classList.add('adj-league-order');
                    adjRankCell.style.color = '#800080'; // Explicitly set purple
                    
                    // Prepare tooltip text
                    const tooltipText = `Adjusted higher due to better league position than ${team.leaguePositionOver}`;
                    
                    // Add tooltip functionality
                    adjValueSpan.dataset.tooltip = tooltipText;
                    adjValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                    adjValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                    
                    // Add the span to the cell
                    adjRankCell.appendChild(adjValueSpan);
                }
                // Show indicator for teams adjusted DOWN due to league position
                else if (team.adjustedDownDueToLeague) {
                    // Create a span for the adjusted rating value that can have a tooltip
                    const adjValueSpan = document.createElement('span');
                    adjValueSpan.textContent = displayValue;
                    adjValueSpan.className = 'record-hover league-adj-down-span'; // Add specific class for downward league adjustment
                    
                    adjRankCell.classList.add('adj-league-order-down');
                    adjRankCell.style.color = '#800080'; // Changed from teal to purple
                    
                    // Prepare tooltip text
                    const tooltipText = `Adjusted lower due to worse league position than ${team.movedDownFor}`;
                    
                    // Add tooltip functionality
                    adjValueSpan.dataset.tooltip = tooltipText;
                    adjValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                    adjValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                    
                    // Add the span to the cell
                    adjRankCell.appendChild(adjValueSpan);
                }
                // Show indicator for teams adjusted UP due to Best-of-3 win
                else if (team.adjustedDueToBestOf3) {
                    const adjValueSpan = document.createElement('span');
                    adjValueSpan.textContent = displayValue;
                    adjValueSpan.className = 'record-hover'; // Add hover class for tooltip
                    
                    adjRankCell.classList.add('adj-best-of-3-win');
                    adjRankCell.style.color = '#007bff'; // Explicitly set blue
                    
                    // Prepare tooltip text
                    const tooltipText = `Adjusted higher due to Best-of-3 match win over ${team.beatInBestOf3}`;
                    
                    // Add tooltip functionality
                    adjValueSpan.dataset.tooltip = tooltipText;
                    adjValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                    adjValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                    
                    // Add the span to the cell
                    adjRankCell.appendChild(adjValueSpan);
                }
                // Show indicator for teams PENALIZED due to Best-of-3 loss
                else if (team.penalizedDueToBo3Loss) {
                    const adjValueSpan = document.createElement('span');
                    adjValueSpan.textContent = displayValue;
                    adjValueSpan.className = 'record-hover'; // Add hover class for tooltip
                    
                    adjRankCell.classList.add('adj-bo3-loss-penalty');
                    adjRankCell.style.color = '#fd7e14'; // Explicitly set orange
                    
                    // Prepare tooltip text
                    const tooltipText = `Rating penalized due to Bo3 loss to ${team.lostBo3To} (not overridden by Bo5 win)`;
                    
                    // Add tooltip functionality
                    adjValueSpan.dataset.tooltip = tooltipText;
                    adjValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                    adjValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                    
                    // Add the span to the cell
                    adjRankCell.appendChild(adjValueSpan);
                }
                // Show indicator for teams adjusted DOWN due to Bo3 loss (rank swap)
                else if (team.adjustedDownDueToBestOf3) {
                    const adjValueSpan = document.createElement('span');
                    adjValueSpan.textContent = displayValue;
                    adjValueSpan.className = 'record-hover adj-bo3-loss-penalty'; // Reuse orange for now

                    adjRankCell.classList.add('adj-bo3-loss-penalty'); // Reuse class for color
                    adjRankCell.style.color = '#fd7e14'; // Explicitly set orange

                    const tooltipText = `Rank adjusted lower due to Bo3 loss to ${team.lostBo3To} (Bo5 precedence allowed swap)`;

                    adjValueSpan.dataset.tooltip = tooltipText;
                    adjValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                    adjValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                    adjRankCell.appendChild(adjValueSpan);
                }
                else {
                    // For regular values with no special adjustment, just show the value without tooltip
                    adjRankCell.textContent = displayValue;
            }
        } else {
                // If no adjusted rating exists, show dash
                adjRankCell.textContent = '-';
            }
        } else {
            // When not sorting by Adj, show only dashes
            adjRankCell.textContent = '-';
        }
        row.appendChild(adjRankCell);
        
        tableBody.appendChild(row);
    });
    
    // After displaying the rankings, set up the sort handlers again
    // This ensures they're attached to the newly created elements
    setupSortHandlers();
    
    // Ensure the indicators are only in the Adj column regardless of sort
    fixIndicatorPlacement();
    
    // Refresh touch events for the newly added tooltip elements
    if (typeof refreshTooltipTouchEvents === 'function') {
        refreshTooltipTouchEvents();
    }
}
            
            function displayWinlessTeams(winlessTeams) {
                const tableBody = document.querySelector('#winless-teams-table tbody');
                tableBody.innerHTML = '';
                
                // Update the table header to include sortable columns with proper IDs
                const tableHead = document.querySelector('#winless-teams-table thead tr');
                tableHead.innerHTML = `
                    <th id="winless-name-sort">Team</th>
                    <th id="winless-rating-sort">Rating</th>
                    <th id="winless-str-sort">Schedule</th>
                    <th id="winless-record-sort">Record</th>
                `;
                
                // Add the active-sort class and sort indicator to the current sort column
                const currentSortHeader = document.getElementById(`winless-${winlessSortState.column}-sort`);
                if (currentSortHeader) {
                    currentSortHeader.classList.add(winlessSortState.direction === 'asc' ? 'sort-indicator-asc' : 'sort-indicator');
                    currentSortHeader.classList.add('active-sort');
                }
                
                logDebug(`Displaying ${winlessTeams.length} teams with no wins`);
                
                if (winlessTeams.length === 0) {
                    const row = document.createElement('tr');
                    const cell = document.createElement('td');
                    cell.colSpan = 4;
                    cell.textContent = 'No teams without wins';
                    cell.style.textAlign = 'center';
                    cell.style.fontStyle = 'italic';
                    row.appendChild(cell);
                    tableBody.appendChild(row);
                    return;
                }

                /* --- build a leagueTeams map so the tooltip
                   can list standings, identical to Rankings --- */
                const leagueTeams = {};
                Object.values(globalTeamMap).forEach(t=>{
                    if (t.league) {
                        (leagueTeams[t.league] ||= []).push(t);
                    }
                });
                Object.values(leagueTeams).forEach(arr =>
                    arr.sort((a,b)=>(a.leagueRank ?? 999)-(b.leagueRank ?? 999)));

                winlessTeams.forEach(team => {
                    const row = document.createElement('tr');
                    
                    const nameCell = document.createElement('td');
                    
                    // --- Link Generation Logic (Copied from displayRankings) --- 
                    let teamPath = globalTeamPaths[team.name];
                    if (!teamPath) {
                        // try again with just the abbreviation part
                        const shortName = team.name.replace(/\s*\\(.+\\)\\s*$/, '').trim();
                        teamPath = globalTeamPaths[shortName];
                        if (teamPath) {
                            logDebug(`Winless: Found path for ${team.name} using fallback short name ${shortName}`);
                        }
                    }
                    let maxPrepsUrl = getMaxPrepsUrl(teamPath); // Use helper function

                    // Create link or span as container
                    let nameContainer;
                    if (maxPrepsUrl) {
                        const link = document.createElement('a');
                        link.href = maxPrepsUrl;
                        link.target = '_blank';
                        link.style.textDecoration = 'none'; // Keep link look consistent
                        link.style.color = 'inherit';
                        nameContainer = link; // Spans will be appended to the link
                    } else {
                        nameContainer = document.createElement('span'); // Use a span if no link
                    }

                    // --- Append Name, Record, League Rank (Copied & adapted from displayRankings) ---
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = team.name + ' (';
                    nameContainer.appendChild(nameSpan);

                    // Add hoverable wins count
                    if (team.record) {
                        // Create span for wins with tooltip
                        const winsSpan = document.createElement('span');
                        winsSpan.className = 'record-hover';
                        winsSpan.textContent = team.record.wins;

                        // Find wins for tooltip
                        const teamWinsData = globalTeamWins[team.name] || []; // Use globalTeamWins
                        if (teamWinsData.length > 0) {
                            const tooltipText = teamWinsData.map(opponent => {
                                const result = findMatchResult(globalMatches, team.name, opponent); // Use globalMatches
                                return result ? `${opponent} (${result})` : opponent;
                            }).join('\n');
                            winsSpan.dataset.tooltip = `Wins Against:\n${tooltipText}`;
                            winsSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                            winsSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                        } else {
                            winsSpan.dataset.tooltip = 'No recorded wins';
                            winsSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                            winsSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                        }
                        nameContainer.appendChild(winsSpan);

                        // Add dash separator
                        const dashSpan1 = document.createElement('span');
                        dashSpan1.textContent = '-';
                        nameContainer.appendChild(dashSpan1);

                        // Create span for losses with tooltip
                        const lossesSpan = document.createElement('span');
                        lossesSpan.className = 'record-hover';
                        lossesSpan.textContent = team.record.losses;

                        // Find losses for tooltip, including opponent info for sorting
                        const teamLosses = [];
                        globalMatches.forEach(match => { // Use globalMatches
                            if (match.teamA === team.name && match.teamBSets > match.teamASets) {
                                const result = findMatchResult(globalMatches, team.name, match.teamB);
                                teamLosses.push({ 
                                    name: match.teamB, 
                                    rating: globalTeamMap[match.teamB]?.rating || 0,
                                    result: result ? ` (${result})` : '' 
                                });
                            } else if (match.teamB === team.name && match.teamASets > match.teamBSets) {
                                const result = findMatchResult(globalMatches, team.name, match.teamA);
                                teamLosses.push({ 
                                    name: match.teamA, 
                                    rating: globalTeamMap[match.teamA]?.rating || 0,
                                    result: result ? ` (${result})` : '' 
                                });
                            }
                        });

                        if (teamLosses.length > 0) {
                            // Sort losses by opponent rating (descending)
                            teamLosses.sort((a, b) => b.rating - a.rating);
                            
                            // Format tooltip string
                            let tooltipContent = `${team.name}'s Losses (in order of opponent str):\n`;
                            teamLosses.forEach((loss, i) => {
                                tooltipContent += `${i+1}. ${loss.name} (${loss.rating.toFixed(3)})${loss.result}\n`;
                            });
                            lossesSpan.dataset.tooltip = tooltipContent.trim(); // Use trim() to remove trailing newline
                            
                            lossesSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                            lossesSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                        } else {
                             lossesSpan.dataset.tooltip = 'No recorded losses';
                            lossesSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                            lossesSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                        }
                        nameContainer.appendChild(lossesSpan);

                        // Add ties if applicable
                        if (team.record.ties > 0) {
                            const dashSpan2 = document.createElement('span');
                            dashSpan2.textContent = '-';
                            nameContainer.appendChild(dashSpan2);

                            const tiesSpan = document.createElement('span');
                            tiesSpan.className = 'record-hover';
                            tiesSpan.textContent = team.record.ties;

                            // Find ties for tooltip
                            const teamTies = [];
                             globalMatches.forEach(match => { // Use globalMatches
                                if ((match.teamA === team.name || match.teamB === team.name) && match.teamASets === match.teamBSets) {
                                    const opponent = match.teamA === team.name ? match.teamB : match.teamA;
                                    const result = findMatchResult(globalMatches, team.name, opponent);
                                    teamTies.push(result ? `${opponent} (${result})` : opponent);
                                }
                            });

                            if (teamTies.length > 0) {
                                tiesSpan.dataset.tooltip = `Ties With:\n${teamTies.join('\n')}`;
                                tiesSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                                tiesSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                            } else {
                                 tiesSpan.dataset.tooltip = 'No recorded ties';
                                tiesSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                                tiesSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                            }
                            nameContainer.appendChild(tiesSpan);
                        }
                    }

                    // Closing parenthesis
                    const closingParenSpan = document.createElement('span');
                    closingParenSpan.textContent = ')';
                    nameContainer.appendChild(closingParenSpan);

                    // Add league rank with tooltip
                    logDebug(`Checking league rank for ${team.name}: value=${team.leagueRank}, type=${typeof team.leagueRank}`); // DEBUG LOG
                    if (team.league && typeof team.leagueRank === 'number' && !isNaN(team.leagueRank) && team.leagueRank > 0) {
                        const leagueRankSpan = document.createElement('span');
                        leagueRankSpan.className = 'league-rank';
                        // Change the leading space and parenthesis to space, hyphen, space
                        leagueRankSpan.textContent = ` - ${team.leagueRank}${getOrdinalSuffix(team.leagueRank)}`; // Include the number AND the suffix

                        // Prepare tooltip text for league standings
                        let leagueTooltipText = `League: ${team.league}\n---\n`;
                        if (leagueTeams[team.league]) {
                            leagueTeams[team.league].forEach(leagueTeam => {
                                const rank = leagueTeam.leagueRank ? `${leagueTeam.leagueRank}${getOrdinalSuffix(leagueTeam.leagueRank)} - ` : ''; // Include number AND suffix
                                const record = leagueTeam.record ? `(${leagueTeam.record.wins}-${leagueTeam.record.losses}${leagueTeam.record.ties > 0 ? '-' + leagueTeam.record.ties : ''})` : '(N/A)';
                                // Add arrow to highlight current team
                                if (leagueTeam.name === team.name) {
                                    leagueTooltipText += `→ ${rank}${leagueTeam.name} ${record}\n`;
                                } else {
                                    leagueTooltipText += `  ${rank}${leagueTeam.name} ${record}\n`;
                                }
                            });
                        } else {
                            leagueTooltipText += 'League standings not available.';
                        }

                        leagueRankSpan.dataset.tooltip = leagueTooltipText.trim();
                        leagueRankSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                        leagueRankSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                        nameContainer.appendChild(leagueRankSpan);
                    }

                    // --- End Append Name, Record, League Rank ---

                    nameCell.appendChild(nameContainer); // Add the container (link or span) to the cell
                    row.appendChild(nameCell); // Add name cell to row
                    
                    const ratingCell = document.createElement('td');
                    ratingCell.textContent = team.rating.toFixed(3);
                    row.appendChild(ratingCell);
                    
                    // Create the strength cell with tooltip showing weighted calculation
                    const strengthCell = document.createElement('td');
                    
                    // Always create a span for the strength value that can have a tooltip
                    const strengthValueSpan = document.createElement('span');
                    strengthValueSpan.textContent = team.scheduleStrength ? team.scheduleStrength.toFixed(3) : 'N/A';
                    strengthValueSpan.className = 'record-hover'; // Add hover class for tooltip
                    
                    if (team.scheduleStrength) {
                        // Prepare tooltip text explaining the weighted calculation
                        let tooltipText = `Top Opponents:\n${team.topOpponents || 'None'}\n`;
                        
                        
                        // Add tooltip functionality
                        strengthValueSpan.dataset.tooltip = tooltipText;
                        strengthValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                        strengthValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                    }
                    
                    // Add the span to the cell
                    strengthCell.appendChild(strengthValueSpan);
                    row.appendChild(strengthCell);
                    
                    const recordCell = document.createElement('td');
                    if (team.record) {
                        recordCell.textContent = `${team.record.wins}-${team.record.losses}${team.record.ties > 0 ? '-' + team.record.ties : ''}`;
                    } else {
                        recordCell.textContent = '0-0';
                    }
                    row.appendChild(recordCell);
                    
                    tableBody.appendChild(row);
                });
                
                // Setup the sort handlers after displaying
                setupWinlessSortHandlers();
                
                // Initialize tooltips for the newly added elements
                initializeAllTooltips(); 
            }
            
            function fetchLeagueData(sheetId, apiKey, teamRankings, matches, teamWins, teamMap) {
                logDebug(`Fetching league data...`);
                
                // Get the selected gender and year for consistency
                const selectedGender = document.getElementById('gender-select').value;
                const selectedYear = document.getElementById('year-select').value;
                
                // Determine the league sheet name based on selections
                let leagueSheetName = "Leagues";
                
                // Now get the "Leagues" sheet
                const leaguesSheetUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${encodeURIComponent(leagueSheetName)}?key=${apiKey}`;
                
                return fetch(leaguesSheetUrl)
                    .then(response => {
                        if (!response.ok) {
                            logDebug(`Response status: ${response.status}`);
                            throw new Error(`Could not access the Leagues sheet. Status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(leagueData => {
                        logDebug(`League data received. Processing ${leagueData.values.length} rows...`, true);
                        
                        // Map teams to their leagues
                        const teamLeagues = {};
                        const leagueTeams = {};
                        // --> Add map for team paths <--
                        const teamPaths = {}; 
                        
                        // Track abbreviations and full names for matching
                        const teamAbbreviations = {};
                        const teamFullNames = {};
                        
                        // Skip header row if it looks like a header
                        const startRow = 
                            leagueData.values[0] && 
                            typeof leagueData.values[0][0] === 'string' && 
                            (leagueData.values[0][0].toLowerCase().includes('team') || 
                             isNaN(parseInt(leagueData.values[0][0].charAt(0)))) ? 1 : 0;
                        
                        logDebug(`Starting from row: ${startRow + 1} (${startRow === 0 ? 'No header detected' : 'Header row skipped'})`);
                        
                        for (let i = startRow; i < leagueData.values.length; i++) {
                            const row = leagueData.values[i];
                            if (row.length < 2) {
                                logDebug(`Row ${i + 1} skipped - not enough columns: ${row.join(', ')}`);
                                continue;
                            }
                            
                            const abbr = row[0] ? row[0].trim() : '';
                            const league = row[1] ? row[1].trim() : '';
                            const fullName = row.length > 3 ? (row[3] ? row[3].trim() : '') : '';
                            // --> Get path from Column C (index 2) <--
                            const path = row.length > 2 ? (row[2] ? row[2].trim() : '') : '';
                            
                            if (!abbr || !league) {
                                logDebug(`Row ${i + 1} skipped - invalid data: ${row.join(', ')}`);
                                continue;
                            }
                            
                            // Store both abbreviation and full name for matching
                            teamAbbreviations[abbr] = league;
                            if (fullName) {
                                teamFullNames[fullName] = league;
                            }
                            
                            // Initialize the league array if needed
                            if (!leagueTeams[league]) {
                                leagueTeams[league] = [];
                            }
                            
                            logDebug(`Mapped abbreviation "${abbr}" and full name "${fullName}" to league "${league}"`);
                            
                            // --> Store path associated with abbreviation and full name <--
                            if (path) {
                                teamPaths[abbr] = path;
                                if (fullName) {
                                    teamPaths[fullName] = path;
                                    // --> also map the combined key exactly as you render it <--
                                    const combinedKey = `${abbr} (${fullName})`;
                                    teamPaths[combinedKey] = path;
                                    logDebug(`Mapped path "${path}" to combined key "${combinedKey}"`); // Added log
                                }
                                logDebug(`Mapped path "${path}" to abbr "${abbr}" and full name "${fullName}"`);
                            }
                        }
                        
                        // Match teams from rankings with leagues
                        const allTeams = new Set();
                        
                        // Collect all team names from rankings and winless teams
                        teamRankings.forEach(team => {
                            allTeams.add(team.name);
                        });
                        
                        // Add any teams from matches that might not be in rankings
                        matches.forEach(match => {
                            allTeams.add(match.teamA);
                            allTeams.add(match.teamB);
                        });
                        
                        // Process all team names to match with leagues
                        allTeams.forEach(teamName => {
                            // Check for pattern like "LAAAE (Los Angeles Academy of Arts & Enterprise)"
                            const namePattern = /^(.+?)\s*\((.+?)\)\s*$/;
                            const match = teamName.match(namePattern);
                            
                            let league = null;
                            
                            if (match) {
                                // We have a name with parentheses format
                                const shortName = match[1].trim();
                                const longName = match[2].trim();
                                
                                // Try to match by abbreviation first
                                if (teamAbbreviations[shortName]) {
                                    league = teamAbbreviations[shortName];
                                    logDebug(`Matched team "${teamName}" to league "${league}" via abbreviation "${shortName}"`);
                                } 
                                // Then try to match by full name
                                else if (teamFullNames[longName]) {
                                    league = teamFullNames[longName];
                                    logDebug(`Matched team "${teamName}" to league "${league}" via full name "${longName}"`);
                                }
                            } else {
                                // Try direct match with abbreviations
                                if (teamAbbreviations[teamName]) {
                                    league = teamAbbreviations[teamName];
                                    logDebug(`Matched team "${teamName}" to league "${league}" via direct abbreviation match`);
                                }
                                // Check if the team name contains any of the abbreviations
                                else {
                                    for (const abbr in teamAbbreviations) {
                                        if (teamName.includes(abbr)) {
                                            league = teamAbbreviations[abbr];
                                            logDebug(`Matched team "${teamName}" to league "${league}" via partial abbreviation "${abbr}"`);
                                            break;
                                        }
                                    }
                                    
                                    // If still no match, check if the team name contains any of the full names
                                    if (!league) {
                                        for (const fullName in teamFullNames) {
                                            if (teamName.includes(fullName)) {
                                                league = teamFullNames[fullName];
                                                logDebug(`Matched team "${teamName}" to league "${league}" via partial full name "${fullName}"`);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // If we found a league match, add to our mappings
                            if (league) {
                                teamLeagues[teamName] = league;
                                if (!leagueTeams[league].includes(teamName)) {
                                    leagueTeams[league].push(teamName);
                                }
                            }
                        });
                        
                        // Calculate league standings
                        const leagueStandings = calculateLeagueStandings(matches, teamLeagues);
                        
                        console.log("About to calculate league strengths");
                        console.log("leagueTeams:", leagueTeams);
                        console.log("teamRankings:", teamRankings);
                        
                        // Calculate league strengths
                        const leagueStrengths = calculateLeagueStrengths(leagueTeams, teamRankings, currentRankings);
                        
                        console.log("League strengths calculated:", leagueStrengths);
                        
                        // Display league strengths
                        displayLeagueStrengths(leagueStrengths, leagueTeams, leagueStandings);
                        
                        console.log("League strengths displayed");
                        
                        logDebug(`League strength calculation complete!`, true);
                        
                        // Add league information to team rankings
                        teamRankings.forEach(team => {
                            if (teamLeagues[team.name]) {
                                team.league = teamLeagues[team.name];
                                if (leagueStandings[team.name]) {
                                    team.leagueRank = leagueStandings[team.name].rank;
                                    team.leagueIsTied = leagueStandings[team.name].isTied;
                                    team.leagueRecord = leagueStandings[team.name].leagueRecord;
                                }
                            }
                        });
                        
                        // Use currentRankings instead of teamRankings to display only teams with wins
                        displayRankings(currentRankings, globalTeamWins, globalTeamMap, globalMatches);
                        displayWinlessTeams(currentWinlessTeams);
                        
                        // --> Store team paths globally <--
                        globalTeamPaths = teamPaths;
                        logDebug(`Stored ${Object.keys(globalTeamPaths).length} team paths globally.`);
                        
                        return {
                            leagueStrengths,
                            teamLeagues,
                            leagueStandings
                        };
                    });
            }
            
            function calculateLeagueStandings(matches, teamLeagues) {
                // Create a map to store league standings
                const leagueStandings = {};
                
                // Create a head-to-head results tracker for tiebreaking
                const headToHeadResults = {};
                
                // Initialize league standings object for each league
                for (const team in teamLeagues) {
                    const league = teamLeagues[team];
                    if (!leagueStandings[league]) {
                        leagueStandings[league] = {};
                    }
                    // Initialize team record within their league
                    leagueStandings[league][team] = { 
                        wins: 0, 
                        losses: 0, 
                        ties: 0,
                        setsWon: 0,   // Track sets won
                        setsLost: 0    // Track sets lost
                    };
                    
                    // Initialize head-to-head tracking
                    if (!headToHeadResults[team]) {
                        headToHeadResults[team] = {};
                    }
                }
                
                // Keep track of matches counted for each league for logging
                const leagueMatchCounts = {};
                
                // Process matches to calculate league standings
                for (const match of matches) {
                    const teamA = match.teamA;
                    const teamB = match.teamB;
                    
                    // Only count matches:
                    // 1. Between teams in the same league
                    // 2. With format 5 (best of 5 matches)
                    if (teamLeagues[teamA] && 
                        teamLeagues[teamB] && 
                        teamLeagues[teamA] === teamLeagues[teamB] &&
                        match.format === 5) {  // Only consider best of 5 matches
                        
                        const league = teamLeagues[teamA];
                        
                        // Track match count for this league
                        if (!leagueMatchCounts[league]) {
                            leagueMatchCounts[league] = 0;
                        }
                        leagueMatchCounts[league]++;
                        
                        // Update sets won/lost for both teams
                        if (leagueStandings[league][teamA]) {
                            leagueStandings[league][teamA].setsWon += match.teamASets;
                            leagueStandings[league][teamA].setsLost += match.teamBSets;
                        }
                        
                        if (leagueStandings[league][teamB]) {
                            leagueStandings[league][teamB].setsWon += match.teamBSets;
                            leagueStandings[league][teamB].setsLost += match.teamASets;
                        }
                        
                        // Update league records based on match result
                        if (match.teamASets > match.teamBSets) {
                            // Team A won
                            leagueStandings[league][teamA].wins++;
                            leagueStandings[league][teamB].losses++;
                            
                            // Track head-to-head result
                            if (!headToHeadResults[teamA][teamB]) headToHeadResults[teamA][teamB] = { wins: 0, losses: 0 };
                            if (!headToHeadResults[teamB][teamA]) headToHeadResults[teamB][teamA] = { wins: 0, losses: 0 };
                            
                            headToHeadResults[teamA][teamB].wins++;
                            headToHeadResults[teamB][teamA].losses++;
                        } else if (match.teamBSets > match.teamASets) {
                            // Team B won
                            leagueStandings[league][teamB].wins++;
                            leagueStandings[league][teamA].losses++;
                            
                            // Track head-to-head result
                            if (!headToHeadResults[teamB][teamA]) headToHeadResults[teamB][teamA] = { wins: 0, losses: 0 };
                            if (!headToHeadResults[teamA][teamB]) headToHeadResults[teamA][teamB] = { wins: 0, losses: 0 };
                            
                            headToHeadResults[teamB][teamA].wins++;
                            headToHeadResults[teamA][teamB].losses++;
                } else {
                            // Tie
                            leagueStandings[league][teamA].ties++;
                            leagueStandings[league][teamB].ties++;
                        }
                    }
                }
                
                // Log match counts by league
                logDebug("League match counts (format 5 only):");
                for (const league in leagueMatchCounts) {
                    const teamCount = Object.keys(leagueStandings[league]).length;
                    const expectedMatches = teamCount * (teamCount - 1); // Each team plays every other team twice
                    logDebug(`  ${league}: ${leagueMatchCounts[league]} matches (${teamCount} teams, expected ${expectedMatches} matches if each team plays others twice)`);
                }
                
                // Calculate rankings within each league
                const leagueRankings = {};
                
                for (const league in leagueStandings) {
                    // Create array of teams with their records
                    const teamsInLeague = Object.keys(leagueStandings[league])
                        .map(team => ({
                            name: team,
                            record: leagueStandings[league][team]
                        }));
                    
                    // For each team, calculate the win percentage and set differential for sorting
                    teamsInLeague.forEach(team => {
                        const totalGames = team.record.wins + team.record.losses + team.record.ties;
                        team.winPercentage = totalGames > 0 ? team.record.wins / totalGames : 0;
                        
                        // Calculate set differential for tie-breaking
                        team.setDifferential = team.record.setsWon - team.record.setsLost;
                        
                        // Add head-to-head results for this team
                        team.headToHead = headToHeadResults[team.name] || {};
                    });
                    
                    // Helper function to resolve ties between two teams
                    function resolveTwoTeamTie(teamA, teamB) {
                        // First check head-to-head
                        const h2hA = teamA.headToHead[teamB.name];
                        const h2hB = teamB.headToHead[teamA.name];
                        
                        if (h2hA && h2hB) {
                            // If one team has more wins against the other, they win the tiebreaker
                            if (h2hA.wins > h2hB.wins) return -1; // teamA wins tiebreaker
                            if (h2hB.wins > h2hA.wins) return 1;  // teamB wins tiebreaker
                        }
                        
                        // If head-to-head is tied or incomplete, use set differential
                        return teamB.setDifferential - teamA.setDifferential;
                    }
                    
                    // Sorting function that uses tiebreakers for teams with identical win percentage
                    function compareTeams(a, b) {
                        // First sort by win percentage
                        if (Math.abs(b.winPercentage - a.winPercentage) > 0.0001) {
                            return b.winPercentage - a.winPercentage;
                        }
                        
                        // If win percentage is equal, use tiebreakers
                        return resolveTwoTeamTie(a, b);
                    }
                    
                    // Sort teams with tiebreakers
                    teamsInLeague.sort(compareTeams);
                    
                    // Find groups of teams with the same win percentage for tiebreakers
                    const winPctGroups = {};
                    teamsInLeague.forEach(team => {
                        const winPctRounded = team.winPercentage.toFixed(6);
                        if (!winPctGroups[winPctRounded]) {
                            winPctGroups[winPctRounded] = [];
                        }
                        winPctGroups[winPctRounded].push(team);
                    });
                    
                    // Process each group to determine final ranking
                    let currentRank = 1;
                    
                    // Sort the win percentage groups to ensure consistent rank order
                    const sortedWinPcts = Object.keys(winPctGroups).sort((a, b) => {
                        return parseFloat(b) - parseFloat(a);
                    });
                    
                    sortedWinPcts.forEach(winPct => {
                        const teamsWithSameWinPct = winPctGroups[winPct];
                        
                        // Sort teams within this win percentage group by tiebreakers
                        teamsWithSameWinPct.sort(compareTeams);
                        
                        // Now we need to determine which teams are actually tied after tiebreakers
                        const tiedGroups = [];
                        let currentTiedGroup = [teamsWithSameWinPct[0]];
                        
                        // Group teams that are truly tied
                        for (let i = 1; i < teamsWithSameWinPct.length; i++) {
                            const currTeam = teamsWithSameWinPct[i];
                            const prevTeam = teamsWithSameWinPct[i-1];
                            
                            if (resolveTwoTeamTie(prevTeam, currTeam) === 0) {
                                // Teams are tied, add to current group
                                currentTiedGroup.push(currTeam);
                            } else {
                                // No tie, finish current group and start a new one
                                tiedGroups.push([...currentTiedGroup]);
                                currentTiedGroup = [currTeam];
                            }
                        }
                        
                        // Add the last group
                        if (currentTiedGroup.length > 0) {
                            tiedGroups.push(currentTiedGroup);
                        }
                        
                        // Now assign ranks to each group
                        tiedGroups.forEach(group => {
                            const isTied = group.length > 1;
                            
                            group.forEach(team => {
                            // Store the rank for this team in this league
                            if (!leagueRankings[team.name]) {
                                leagueRankings[team.name] = {};
                            }
                            
                                // Include set differential and head-to-head info in the team record for the tooltip
                            leagueRankings[team.name] = {
                                rank: currentRank,
                                isTied: isTied,
                                leagueRecord: team.record,
                                    league: league,
                                    setDifferential: team.setDifferential,
                                    headToHead: team.headToHead
                            };
                        });
                        
                        // Move rank forward based on number of teams in this group
                            currentRank += group.length;
                        });
                    });
                }
                
                return leagueRankings;
            }
            
            function calculateLeagueStrengths(leagueTeams, teamRankings, rankings) {
                logDebug(`Calculating league strengths...`);
                console.log("Starting league strength calculation", leagueTeams, teamRankings, rankings);
                
                // Create maps for easier lookup of team ratings
                const standardRatingMap = {};
                const adjustedRatingMap = {};
                const rankMap = {}; // Track each team's rank
                
                teamRankings.forEach((team, index) => {
                    standardRatingMap[team.name] = team.rating;
                    adjustedRatingMap[team.name] = team.adjustedRating !== undefined ? team.adjustedRating : team.rating;
                    rankMap[team.name] = index + 1; // Store 1-based rank
                });
                
                console.log("Rating maps created");
                
                const leagueStrengths = [];
                
                // Calculate weighted average rating for each league
                for (const league in leagueTeams) {
                    console.log(`\n--- Processing league: ${league} ---`);
                    const teams = leagueTeams[league];
                    
                    // For weighted average calculation
                    const teamsWithRatingsArray = [];
                    
                    // Log details of each team in the league
                    console.log(`Teams in ${league}:`);
                    teams.forEach(team => {
                        // Handle both string team names and team objects
                        const teamName = typeof team === 'object' ? team.name : team;
                        
                        // Check if the team exists in the rating maps
                        if (standardRatingMap[teamName] !== undefined) {
                            const stdRating = standardRatingMap[teamName];
                            const adjRating = adjustedRatingMap[teamName];
                            const rank = rankMap[teamName];
                            
                            console.log(`  ${teamName}:`); 
                            console.log(`    Rank: #${rank}`);
                            console.log(`    Standard Rating: ${stdRating.toFixed(3)}`);
                            console.log(`    Adjusted Rating: ${adjRating.toFixed(3)}`);
                            
                            // Store team data for weighted average calculation
                            teamsWithRatingsArray.push({
                                name: teamName,
                                stdRating,
                                adjRating,
                                rank
                            });
                        } else {
                            console.log(`  ${teamName}: NO RATING (not found in ranking data)`);
                        }
                    });
                    
                    // Sort teams by adjusted rating (descending)
                    teamsWithRatingsArray.sort((a, b) => b.adjRating - a.adjRating);
                    
                    // Calculate weighted average based on team position in the sorted list
                    let weightedSum = 0;
                    let totalWeight = 0;
                    let teamsWithRatings = teamsWithRatingsArray.length;
                    
                    if (teamsWithRatings > 0) {
                        console.log(`  Calculating weighted average for ${teamsWithRatings} teams:`);
                        
                        teamsWithRatingsArray.forEach((team, index) => {
                            // Calculate weight - higher for top teams, decaying for lower teams
                            // First 4 teams get weights of 5, 4, 3, 2
                            let weight;
                            if (index < 4) {
                                // Top 4 teams get weights of 5, 4, 3, 2
                                weight = 5 - index;
                            } else {
                                // Teams after the top 4 get exponentially decreasing weights
                                // This formula gives weight of ~1.5 for 5th team, then decays toward 0
                                weight = 2 * Math.exp(-0.5 * (index - 3));
                            }
                            
                            weightedSum += team.adjRating * weight;
                            totalWeight += weight;
                            
                            console.log(`    ${team.name} (Rank #${team.rank}): Rating ${team.adjRating.toFixed(3)}, Weight ${weight.toFixed(2)}`);
                        });
                        
                        console.log(`  Total weight: ${totalWeight.toFixed(2)}`);
                    }
                    
                    // Calculate the weighted strength
                    const weightedStrength = totalWeight > 0 ? weightedSum / totalWeight : 0;
                    
                    console.log(`League "${league}" summary:`);
                    console.log(`  Teams with ratings: ${teamsWithRatings}/${teams.length}`);
                    console.log(`  Weighted Adjusted Strength: ${weightedStrength.toFixed(3)}`);
                    
                    leagueStrengths.push({
                        name: league,
                        weightedStrength: weightedStrength,
                        teamsCount: teams.length,
                        teamsWithRatings: teamsWithRatings,
                        topTeams: teamsWithRatingsArray.slice(0, 4).map(t => {
                            // Get the team's adjusted rank from the rankings array
                            const teamRank = rankings.findIndex(r => r.name === t.name) + 1;
                            return `${t.name} (${teamRank})`;
                        }).join(', ')
                    });
                    
                    logDebug(`League "${league}": Weighted Strength ${weightedStrength.toFixed(3)} (emphasizing top teams)`);
                }
                
                console.log("\n--- Completed league strengths calculation ---");
                
                // Sort by weighted strength in descending order
                leagueStrengths.sort((a, b) => b.weightedStrength - a.weightedStrength);
                
                console.log("Sorted league strengths:", leagueStrengths.map(l => 
                    `${l.name}: ${l.weightedStrength.toFixed(3)} (${l.teamsWithRatings}/${l.teamsCount} teams)`
                ).join('\n'));
                
                return leagueStrengths;
            }
            
            function displayLeagueStrengths(leagueStrengths, leagueTeams, leagueStandings) {
                console.log("Starting to display league strengths:", leagueStrengths, leagueTeams, leagueStandings);
                
                if (!leagueStrengths || leagueStrengths.length === 0) {
                    console.error("No league strengths data to display!");
                    return;
                }
                
                // Remove any existing league strength section
                const existingSections = document.querySelectorAll('.section-divider');
                existingSections.forEach(section => {
                    const heading = section.querySelector('h3');
                    if (heading && heading.textContent === 'League Strength') {
                        section.remove();
                    }
                });
                
                const leagueSection = document.createElement('div');
                leagueSection.className = 'section-divider';
                
                const heading = document.createElement('h3');
                heading.textContent = 'League Strength';
                leagueSection.appendChild(heading);
                
                const table = document.createElement('table');
                table.id = 'league-strength-table'; // Changed ID to avoid conflict
                
                // Create table header with sortable columns
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                const leagueHeader = document.createElement('th');
                leagueHeader.id = 'league-name-sort';
                leagueHeader.textContent = 'League';
                headerRow.appendChild(leagueHeader);
                
                const strengthHeader = document.createElement('th');
                strengthHeader.id = 'league-weighted-sort';
                strengthHeader.textContent = 'Strength (Weighted)';
                headerRow.appendChild(strengthHeader);
                
                const topTeamsHeader = document.createElement('th');
                topTeamsHeader.id = 'league-topteams-sort';
                topTeamsHeader.textContent = 'Top Teams';
                headerRow.appendChild(topTeamsHeader);
                
                const teamsHeader = document.createElement('th');
                teamsHeader.id = 'league-teams-sort';
                teamsHeader.textContent = 'Teams';
                headerRow.appendChild(teamsHeader);
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                
                leagueStrengths.forEach(lg => {
                    console.log(`Processing league: ${lg.name}`); // Use lg.name
                    const row = document.createElement('tr');
                    
                    const nameCell = document.createElement('td');
                    const strengthCell = document.createElement('td'); // Renamed for clarity
                    const topTeamsCell = document.createElement('td');
                    const teamsCountCell = document.createElement('td');

                    /* ----------  league name with tooltip  ---------- */
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'league-rank record-hover';   // blue + "help" cursor
                    nameSpan.textContent = lg.name;                  // Use lg.name

                    /* Build tooltip text */
                    let tip = `${lg.name} League – current standings\n`; // Use lg.name and escape newline
                    if (leagueTeams && leagueTeams[lg.name] && leagueStandings) { // Check if data exists
                        /* sort by stored leagueRank (1,2,3…) */
                        const teams = [...leagueTeams[lg.name]]
                                      .sort((a,b) => {
                                         const teamAStandings = leagueStandings[a];
                                         const teamBStandings = leagueStandings[b];
                                         const r1 = teamAStandings?.rank ?? 999;
                                         const r2 = teamBStandings?.rank ?? 999;
                                         // If ranks are equal, tiebreak with set differential (higher is better)
                                         if (r1 === r2) {
                                             const diff1 = teamAStandings?.setDifferential ?? -Infinity;
                                             const diff2 = teamBStandings?.setDifferential ?? -Infinity;
                                             return diff2 - diff1; // Higher set differential first
                                         }
                                         return r1 - r2; // Otherwise sort by rank
                                      });

                        teams.forEach(t => {
                            const standings = leagueStandings[t];
                            const rk = standings?.rank;
                            const suf = rk ? getOrdinalSuffix(rk) : '';
                            const tied = standings?.isTied ? '(Tied)' : '';
                            tip += `${rk ?? ''}${suf}${tied}${rk ? ' – ' : ''}${t}\n`; // Escape newline
                        });
                    } else {
                        tip += 'No team standings data available';
                    }

                    /* wire-up tooltip */
                    nameSpan.dataset.tooltip = tip.trim();
                    nameSpan.addEventListener('mouseenter', handleTooltipMouseEnter);
                    nameSpan.addEventListener('mouseleave', handleTooltipMouseLeave);

                    nameCell.appendChild(nameSpan);
                    // -------- End Tooltip --------

                    strengthCell.textContent = lg.weightedStrength ? lg.weightedStrength.toFixed(3) : 'N/A'; // Use lg.weightedStrength
                    topTeamsCell.textContent = lg.topTeams || 'N/A';
                    teamsCountCell.textContent = `${lg.teamsWithRatings}/${lg.teamsCount}`; // Use lg.teamsWithRatings and lg.teamsCount
                    
                    row.appendChild(nameCell);
                    row.appendChild(strengthCell);
                    row.appendChild(topTeamsCell);
                    row.appendChild(teamsCountCell);
                    tbody.appendChild(row);
                });
                
                table.appendChild(thead);
                table.appendChild(tbody); // Append tbody after filling it
                
                leagueSection.appendChild(table);
                
                // Add a note explaining the column
                const noteDiv = document.createElement('p');
                noteDiv.className = 'small-note';
                noteDiv.innerHTML = 'Note: "Strength (Weighted)" uses a weighted average of adjusted ratings that prioritizes ' +
                    'top teams while still considering all teams. The top 4 teams receive the highest weights (5, 4, 3, 2), ' +
                    'with weights decreasing exponentially for lower-ranked teams. "Top Teams" shows the four highest-ranked teams in each league.';
                leagueSection.appendChild(noteDiv);
                
                // Get the results div and append the league section
                const resultsDiv = document.getElementById('results');
                if (resultsDiv) {
                    resultsDiv.appendChild(leagueSection);
                } else {
                    console.error("Could not find results div to append league section!");
                }
                
                // Set default sort to weighted strength
                if (!leagueSortState.column || leagueSortState.column === 'strength' || leagueSortState.column === 'top' || leagueSortState.column === 'adjusted' || leagueSortState.column === 'standard') {
                    leagueSortState.column = 'weighted';
                    leagueSortState.direction = 'desc';
                }
                
                // Add event listeners to the table headers after they're added to the DOM
                document.getElementById('league-name-sort').addEventListener('click', () => sortLeagueStrengths('name'));
                document.getElementById('league-weighted-sort').addEventListener('click', () => sortLeagueStrengths('weighted'));
                document.getElementById('league-topteams-sort').addEventListener('click', () => sortLeagueStrengths('topteams'));
                document.getElementById('league-teams-sort').addEventListener('click', () => sortLeagueStrengths('teams'));
                
                // After adding to DOM, ensure we add sort indicator to correct column
                setTimeout(() => {
                    const sortHeader = document.getElementById(`league-${leagueSortState.column}-sort`);
                    if (sortHeader) {
                        sortHeader.classList.add(leagueSortState.direction === 'asc' ? 'sort-indicator-asc' : 'sort-indicator');
                        sortHeader.classList.add('active-sort');
                    }
                }, 0);
                
                // Add event listeners for sorting
                addSortListenersToLeagueTable(table.id);
                
                // Initialize tooltips after adding the new elements
                initializeAllTooltips?.(); // Make sure this picks up the new spans
            }
            
            function addSortListenersToLeagueTable(tableId) {
                // ... existing code ...
            }
            
            // Function to sort winless teams table
            function sortWinlessTeams(column) {
                console.log(`Sorting winless teams by: ${column}`);
                
                // Reset all sort indicators
                document.querySelectorAll('#winless-teams-table th').forEach(th => {
                    th.classList.remove('sort-indicator');
                    th.classList.remove('sort-indicator-asc');
                    th.classList.remove('active-sort');
                });
                
                // If clicking the same column, toggle direction
                if (winlessSortState.column === column) {
                    winlessSortState.direction = winlessSortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    winlessSortState.column = column;
                    winlessSortState.direction = 'desc'; // Default to descending
                }
                
                console.log(`Winless sort state: column=${winlessSortState.column}, direction=${winlessSortState.direction}`);
                
                // Add sort indicator and active-sort class
                const thElement = document.getElementById(`winless-${column}-sort`);
                console.log(`Found winless element for ${column}:`, thElement);
                
                if (thElement) {
                    thElement.classList.add(winlessSortState.direction === 'asc' ? 'sort-indicator-asc' : 'sort-indicator');
                    thElement.classList.add('active-sort');
                    console.log(`Applied classes to winless ${column} column`);
                } else {
                    console.error(`Could not find winless element with ID: winless-${column}-sort`);
                }
                
                // Sort the winless teams
                if (column === 'rating') {
                    currentWinlessTeams.sort((a, b) => {
                        return winlessSortState.direction === 'asc' ? 
                            a.rating - b.rating : 
                            b.rating - a.rating;
                    });
                } else if (column === 'str') {
                    currentWinlessTeams.sort((a, b) => {
                        const strA = a.scheduleStrength || 0;
                        const strB = b.scheduleStrength || 0;
                        return winlessSortState.direction === 'asc' ? 
                            strA - strB : 
                            strB - strA;
                    });
                } else if (column === 'name') {
                    currentWinlessTeams.sort((a, b) => {
                        return winlessSortState.direction === 'asc' ? 
                            a.name.localeCompare(b.name) : 
                            b.name.localeCompare(a.name);
                    });
                } else if (column === 'record') {
                    currentWinlessTeams.sort((a, b) => {
                        const lossesA = a.record ? a.record.losses : 0;
                        const lossesB = b.record ? b.record.losses : 0;
                        return winlessSortState.direction === 'asc' ? 
                            lossesA - lossesB : 
                            lossesB - lossesA;
                    });
                }
                
                // Redisplay the winless teams
                displayWinlessTeams(currentWinlessTeams);
            }
            
            // Setup winless table sort handlers
            function setupWinlessSortHandlers() {
                console.log('Setting up sort handlers for winless teams table');
                
                // Get the column headers
                const nameColumn = document.getElementById('winless-name-sort');
                const ratingColumn = document.getElementById('winless-rating-sort');
                const strColumn = document.getElementById('winless-str-sort');
                const recordColumn = document.getElementById('winless-record-sort');
                
                console.log('Winless column elements:', {
                    name: nameColumn,
                    rating: ratingColumn,
                    str: strColumn,
                    record: recordColumn
                });
                
                // Attach click handlers
                if (nameColumn) {
                    nameColumn.replaceWith(nameColumn.cloneNode(true));
                    document.getElementById('winless-name-sort').addEventListener('click', function() {
                        console.log('Winless name column clicked');
                        sortWinlessTeams('name');
                    });
                }
                
                if (ratingColumn) {
                    ratingColumn.replaceWith(ratingColumn.cloneNode(true));
                    document.getElementById('winless-rating-sort').addEventListener('click', function() {
                        console.log('Winless rating column clicked');
                        sortWinlessTeams('rating');
                    });
                }
                
                if (strColumn) {
                    strColumn.replaceWith(strColumn.cloneNode(true));
                    document.getElementById('winless-str-sort').addEventListener('click', function() {
                        console.log('Winless Schedule column clicked');
                        sortWinlessTeams('str');
                    });
                }
                
                if (recordColumn) {
                    recordColumn.replaceWith(recordColumn.cloneNode(true));
                    document.getElementById('winless-record-sort').addEventListener('click', function() {
                        console.log('Winless record column clicked');
                        sortWinlessTeams('record');
                    });
                }
            }
            
            // Function to sort league strength table
            function sortLeagueStrengths(column) {
                console.log("Sorting league strengths by column:", column);
                
                // Get current league strengths
                const leagueTable = document.getElementById('league-strength-table');
                if (!leagueTable) {
                    console.error("League strength table not found!");
                    return;
                }
                
                // Reset all sort indicators and active class
                document.querySelectorAll('#league-strength-table th').forEach(th => {
                    th.classList.remove('sort-indicator');
                    th.classList.remove('sort-indicator-asc');
                    th.classList.remove('active-sort');
                });
                
                // If clicking the same column, toggle direction
                if (leagueSortState.column === column) {
                    leagueSortState.direction = leagueSortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    leagueSortState.column = column;
                    leagueSortState.direction = 'desc'; // Default to descending
                }
                
                console.log("Sort state:", leagueSortState);
                
                // Add sort indicator and active class
                const thElement = document.getElementById(`league-${column}-sort`);
                if (thElement) {
                    thElement.classList.add(leagueSortState.direction === 'asc' ? 'sort-indicator-asc' : 'sort-indicator');
                    thElement.classList.add('active-sort');
                } else {
                    console.error(`Could not find header element for column ${column}`);
                }
                
                // Get rows from table and convert to array for sorting
                const rows = Array.from(leagueTable.querySelectorAll('tbody tr'));
                console.log("Found", rows.length, "rows to sort");
                
                // Skip if there's only one row (likely the "No league data available" message)
                if (rows.length <= 1) {
                    console.log("Not enough rows to sort");
                    return;
                }
                
                try {
                // Sort the rows
                rows.sort((rowA, rowB) => {
                    let valueA, valueB;
                    
                    if (column === 'name') {
                        valueA = rowA.cells[0].textContent;
                        valueB = rowB.cells[0].textContent;
                        return leagueSortState.direction === 'asc' ? 
                            valueA.localeCompare(valueB) : 
                            valueB.localeCompare(valueA);
                    } 
                        else if (column === 'weighted') {
                            // Weighted strength is in the second column (index 1)
                        valueA = parseFloat(rowA.cells[1].textContent) || 0;
                        valueB = parseFloat(rowB.cells[1].textContent) || 0;
                        return leagueSortState.direction === 'asc' ? 
                            valueA - valueB : 
                            valueB - valueA;
                    }
                        else if (column === 'topteams') {
                            // Top teams is in the third column (index 2)
                        // Get the first team's rank from each list (format: "Team1 (1), Team2 (2), ...")
                        const getFirstRank = text => {
                            const match = text.match(/\((\d+)\)/);
                            return match ? parseInt(match[1]) : Number.MAX_SAFE_INTEGER;
                        };
                        valueA = getFirstRank(rowA.cells[2].textContent);
                        valueB = getFirstRank(rowB.cells[2].textContent);
                            return leagueSortState.direction === 'asc' ? 
                            valueA - valueB : 
                            valueB - valueA;
                    }
                    else if (column === 'teams') {
                            // Teams column is now the fourth column (index 3)
                            const matchA = rowA.cells[3].textContent.match(/(\d+)\/(\d+)/);
                            const matchB = rowB.cells[3].textContent.match(/(\d+)\/(\d+)/);
                        
                        // Use ratio of teams with ratings to total teams
                        valueA = matchA ? parseInt(matchA[1]) / parseInt(matchA[2]) : 0;
                        valueB = matchB ? parseInt(matchB[1]) / parseInt(matchB[2]) : 0;
                        
                        return leagueSortState.direction === 'asc' ? 
                            valueA - valueB : 
                            valueB - valueA;
                    }
                        
                        // Default return if none of the columns match (shouldn't happen)
                        return 0;
                });
                
                // Reorder the table rows
                const tbody = leagueTable.querySelector('tbody');
                rows.forEach(row => tbody.appendChild(row));
                    console.log("Sorting complete");
                } catch (error) {
                    console.error("Error sorting league table:", error);
                }
            }
            
            // Helper function to get ordinal suffix (1st, 2nd, 3rd, etc.)
            function getOrdinalSuffix(n) {
                // Use Intl.PluralRules for robust ordinal handling
                const pr = new Intl.PluralRules("en", { type: "ordinal" });
                const suffixes = {
                    one: "st", // for 1, 21, 31, etc.
                    two: "nd", // for 2, 22, 32, etc.
                    few: "rd", // for 3, 23, 33, etc.
                    other: "th", // for 4, 5, 6, ..., 11, 12, 13, etc.
                };
                return suffixes[pr.select(n)];
            }

            // Create tooltip container
            const tooltipContainer = document.createElement('div');
            tooltipContainer.className = 'custom-tooltip';
            tooltipContainer.style.display = 'none';
            document.body.appendChild(tooltipContainer);

            // Track current tooltip timer
            let tooltipTimer = null;

            // Handle tooltip cleanup when mouse leaves the window
            document.addEventListener('mouseleave', () => {
                if (tooltipTimer) clearTimeout(tooltipTimer);
                tooltipContainer.style.opacity = '0';
                setTimeout(() => {
                    tooltipContainer.style.display = 'none';
                }, 150);
            });

            // Extract common tooltip handling into separate functions
            function handleTooltipMouseEnter(e) {
                // Clear any existing timer
                if (tooltipTimer) clearTimeout(tooltipTimer);
                
                // Set tooltip content and position
                tooltipContainer.textContent = e.target.dataset.tooltip;
                
                // Position tooltip near the cursor
                const rect = e.target.getBoundingClientRect();
                tooltipContainer.style.top = `${rect.bottom + window.scrollY + 5}px`;
                tooltipContainer.style.left = `${rect.left + window.scrollX}px`;
                
                // Show tooltip with slight delay
                tooltipTimer = setTimeout(() => {
                    tooltipContainer.style.display = 'block';
                    // Use a small timeout to trigger CSS transition
                    setTimeout(() => {
                        tooltipContainer.style.opacity = '1';
                    }, 10);
                }, 300);
            }

            // Special handler for Adj column tooltips - positions them to the left
            function handleAdjTooltipMouseEnter(e) {
                // Clear any existing timer
                if (tooltipTimer) clearTimeout(tooltipTimer);
                
                // Set tooltip content and position
                tooltipContainer.textContent = e.target.dataset.tooltip;
                
                // Position tooltip to the LEFT of the cursor
                const rect = e.target.getBoundingClientRect();
                tooltipContainer.style.top = `${rect.top + window.scrollY - 5}px`;
                
                // Calculate tooltip width based on content length, allowing for more space
                // Increased multiplier from 7 to 8 and increased max width to 550px to match CSS
                const tooltipWidth = Math.min(550, e.target.dataset.tooltip.length * 8);
                
                // Calculate left position, ensuring it doesn't go off-screen
                // Reduce the offset from tooltipWidth + 20 to tooltipWidth + 5 to move tooltip more to the right
                let leftPos = rect.left + window.scrollX - tooltipWidth + 200;
                
                // Ensure tooltip doesn't go off the left edge of the screen
                if (leftPos < 10) {
                    leftPos = 10;
                }
                
                // Position to the left of the element, pointing toward the middle of the page
                tooltipContainer.style.left = `${leftPos}px`;
                
                // Show tooltip with slight delay
                tooltipTimer = setTimeout(() => {
                    tooltipContainer.style.display = 'block';
                    // Use a small timeout to trigger CSS transition
                    setTimeout(() => {
                        tooltipContainer.style.opacity = '1';
                    }, 10);
                }, 300);
            }

            function handleTooltipMouseLeave() {
                // Clear show timer if it exists
                if (tooltipTimer) clearTimeout(tooltipTimer);
                
                // Hide tooltip
                tooltipContainer.style.opacity = '0';
                tooltipTimer = setTimeout(() => {
                    tooltipContainer.style.display = 'none';
                }, 150);
            }

            // Function to handle tooltip touch events for mobile devices (iOS/iPad)
            function setupTooltipTouchEvents() {
                // Store the currently active tooltip element
                let activeTooltipElement = null;
                
                // Function to handle touch start on elements with tooltips
                function handleTooltipTouchStart(e) {
                    e.preventDefault(); // Prevent default touch behavior like scrolling
                    
                    // If there's already an active tooltip on a different element, hide it
                    if (activeTooltipElement && activeTooltipElement !== e.currentTarget) {
                        handleTooltipMouseLeave();
                        activeTooltipElement = null;
                    }
                    
                    // Toggle tooltip on the touched element
                    if (activeTooltipElement === e.currentTarget) {
                        // If touching the same element again, hide the tooltip
                        handleTooltipMouseLeave();
                        activeTooltipElement = null;
                    } else {
                        // If touching a new element, show its tooltip
                        // Check if this is an Adj tooltip by looking at parent element class
                        const isAdjTooltip = e.currentTarget.parentElement && 
                            (e.currentTarget.parentElement.classList.contains('adj-needs-adjustment') || 
                             e.currentTarget.parentElement.classList.contains('adj-five-set-win'));
                        
                        // Check if this is a Schedule column tooltip by checking its position in the table
                        const isScheduleTooltip = e.currentTarget.classList.contains('record-hover') && 
                            ((e.currentTarget.closest('td') && 
                              e.currentTarget.closest('td').cellIndex === 3 && 
                              e.currentTarget.closest('table#rankings-table')) || 
                             (e.currentTarget.closest('td') && 
                              e.currentTarget.closest('td').cellIndex === 2 && 
                              e.currentTarget.closest('table#winless-teams-table')));
                        
                        if (isAdjTooltip || isScheduleTooltip) {
                            handleAdjTooltipMouseEnter(e);
                        } else {
                            handleTooltipMouseEnter(e);
                        }
                        
                        activeTooltipElement = e.currentTarget;
                    }
                }
                
                // Function to handle touch outside tooltip elements (to dismiss tooltips)
                function handleDocumentTouchStart(e) {
                    // If touching outside any tooltip element, hide any active tooltip
                    if (activeTooltipElement && 
                        e.target !== activeTooltipElement && 
                        !activeTooltipElement.contains(e.target)) {
                        handleTooltipMouseLeave();
                        activeTooltipElement = null;
                    }
                }
                
                // Add touch events to all elements with tooltips
                function refreshTooltipTouchEvents() {
                    // Find all elements with tooltips
                    const tooltipElements = document.querySelectorAll('.record-hover, .league-rank, [data-tooltip]');
                    
                    // Add touch event listeners
                    tooltipElements.forEach(element => {
                        // Remove any existing touch listeners first to prevent duplicates
                        element.removeEventListener('touchstart', handleTooltipTouchStart);
                        // Add the touch start listener
                        element.addEventListener('touchstart', handleTooltipTouchStart);
                    });
                    
                    // Add document touch listener to hide tooltips when touching elsewhere
                    document.removeEventListener('touchstart', handleDocumentTouchStart);
                    document.addEventListener('touchstart', handleDocumentTouchStart);
                    
                    // Add touch listener to table headers to ensure tooltips are hidden when sorting
                    const tableHeaders = document.querySelectorAll('th');
                    tableHeaders.forEach(header => {
                        header.addEventListener('touchstart', function() {
                            if (activeTooltipElement) {
                                handleTooltipMouseLeave();
                                activeTooltipElement = null;
                            }
                        });
                    });
                }
                
                // Initial setup
                refreshTooltipTouchEvents();
                
                // Return the refresh function so it can be called after content updates
                return refreshTooltipTouchEvents;
            }
            
            // Initialize touch events and get the refresh function
            const refreshTooltipTouchEvents = setupTooltipTouchEvents();

            // Add styles for record hover elements
            const recordStyle = document.createElement('style');
            recordStyle.textContent = `
            .record-hover {
                color: #17215f;
                cursor: help;
                font-weight: bold;
            }
            
            /* Style for adjusted rating hover tooltips */
            .adj-needs-adjustment .record-hover {
                color: #cc0000 !important;
                cursor: help;
                font-weight: bold;
            }
            
            .adj-five-set-win .record-hover {
                color: #007e33 !important;
                cursor: help;
                font-weight: bold;
            }
            
            /* Mobile-specific tooltip improvements */
            @media (hover: none) {
                .custom-tooltip {
                    padding: 12px 15px;
                    font-size: 14px;
                    max-width: 90%; /* Increased from 80% to 90% */
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                }
                
                .record-hover, .league-rank, [data-tooltip] {
                    cursor: pointer;
                    user-select: none;
                    -webkit-tap-highlight-color: transparent;
                }
                
                /* Special styling for Adj column tooltips on mobile - removed underlines */
                .adj-needs-adjustment .record-hover {
                    /* Removed dotted underline */
                }
                
                .adj-five-set-win .record-hover {
                    /* Removed dotted underline */
                }
                
                /* Enhance tap target size for better usability on mobile */
                .record-hover {
                    padding: 2px 0;
                }
            }
            `;
            document.head.appendChild(recordStyle);

            // Update the findMatchResult function to handle all possible match formats
            function findMatchResult(matches, teamA, teamB) {
                const results = [];
                
                for (const match of matches) {
                    // Check both directions (teamA vs teamB and teamB vs teamA)
                    if ((match.teamA === teamA && match.teamB === teamB) || 
                        (match.teamA === teamB && match.teamB === teamA)) {
                        
                        let result = '';
                        
                        if (match.teamA === teamA) {
                            // Team A is our target team
                            if (match.teamASets > match.teamBSets) {
                                result = `W ${match.teamASets}-${match.teamBSets}`;
                            } else if (match.teamBSets > match.teamASets) {
                                result = `L ${match.teamASets}-${match.teamBSets}`;
                            } else {
                                result = `T ${match.teamASets}-${match.teamBSets}`;
                            }
                        } else {
                            // Team B is our target team (so we need to reverse the scores)
                            if (match.teamBSets > match.teamASets) {
                                result = `W ${match.teamBSets}-${match.teamASets}`;
                            } else if (match.teamASets > match.teamBSets) {
                                result = `L ${match.teamBSets}-${match.teamASets}`;
                            } else {
                                result = `T ${match.teamBSets}-${match.teamASets}`;
                            }
                        }
                        
                        // Add date if available
                        if (match.date) {
                            result += ` (${match.date})`;
                        }
                        
                        results.push(result);
                    }
                }
                
                return results.length > 0 ? results.join(", ") : null; // Return all results or null if none found
            }

            // Add a function to create the matchup prediction section
            function createMatchupPredictionSection() {
                // Remove any existing matchup prediction section
                const existingPredictionSection = document.getElementById('matchup-prediction-section');
                if (existingPredictionSection) {
                    existingPredictionSection.remove();
                }
                
                // Create the section container
                const predictionSection = document.createElement('div');
                predictionSection.className = 'section-divider';
                predictionSection.id = 'matchup-prediction-section';
                
                // Add heading
                const heading = document.createElement('h3');
                heading.textContent = 'Matchup Predictor';
                predictionSection.appendChild(heading);
                
                // Add description
                const description = document.createElement('p');
                description.textContent = 'Select two teams to predict the outcome of a match between them:';
                predictionSection.appendChild(description);
                
                // Create the selection controls
                const selectionDiv = document.createElement('div');
                selectionDiv.className = 'matchup-selection';
                
                // Create a flex container for the team selectors
                const teamSelectorsContainer = document.createElement('div');
                teamSelectorsContainer.className = 'team-selectors-container';
                
                // Team A selection
                const teamADiv = document.createElement('div');
                teamADiv.className = 'team-select';
                
                const teamALabel = document.createElement('label');
                teamALabel.textContent = 'Team A:';
                teamALabel.setAttribute('for', 'team-a-select');
                teamADiv.appendChild(teamALabel);
                
                const teamASelect = document.createElement('select');
                teamASelect.id = 'team-a-select';
                teamADiv.appendChild(teamASelect);
                
                // Team B selection
                const teamBDiv = document.createElement('div');
                teamBDiv.className = 'team-select';
                
                const teamBLabel = document.createElement('label');
                teamBLabel.textContent = 'Team B:';
                teamBLabel.setAttribute('for', 'team-b-select');
                teamBDiv.appendChild(teamBLabel);
                
                const teamBSelect = document.createElement('select');
                teamBSelect.id = 'team-b-select';
                teamBDiv.appendChild(teamBSelect);
                
                // Add teams to the container
                teamSelectorsContainer.appendChild(teamADiv);
                teamSelectorsContainer.appendChild(teamBDiv);
                
                // Add the team selectors container to the main selection div
                selectionDiv.appendChild(teamSelectorsContainer);
                
                // Rating type selection - now below the team selectors
                const ratingTypeDiv = document.createElement('div');
                ratingTypeDiv.className = 'rating-type-select';
                
                const ratingTypeLabel = document.createElement('label');
                ratingTypeLabel.textContent = 'Use Rating:';
                ratingTypeLabel.setAttribute('for', 'rating-type-select');
                ratingTypeDiv.appendChild(ratingTypeLabel);
                
                const ratingTypeSelect = document.createElement('select');
                ratingTypeSelect.id = 'rating-type-select';
                
                // Add options for different rating types
                const standardOption = document.createElement('option');
                standardOption.value = 'standard';
                standardOption.textContent = 'Standard Rating';
                ratingTypeSelect.appendChild(standardOption);
                
                const adjustedOption = document.createElement('option');
                adjustedOption.value = 'adjusted';
                adjustedOption.textContent = 'Adjusted Rating';
                adjustedOption.selected = true;
                ratingTypeSelect.appendChild(adjustedOption);
                
                ratingTypeDiv.appendChild(ratingTypeSelect);
                selectionDiv.appendChild(ratingTypeDiv);
                
                // Predict button
                const predictButton = document.createElement('button');
                predictButton.id = 'predict-button';
                predictButton.textContent = 'Predict Outcome';
                predictButton.className = 'predict-button';
                selectionDiv.appendChild(predictButton);
                
                predictionSection.appendChild(selectionDiv);
                
                // Results area
                const resultsDiv = document.createElement('div');
                resultsDiv.id = 'prediction-results';
                resultsDiv.className = 'prediction-results';
                resultsDiv.style.display = 'none';
                predictionSection.appendChild(resultsDiv);
                
                // Add the section to the results container
                document.getElementById('results').appendChild(predictionSection);
                
                // Create the hypothetical results section (just once)
                createHypotheticalResultsSection();
                
                return predictionSection;
            }

            // Function to create the hypothetical results section
            function createHypotheticalResultsSection() {
                // Remove any existing hypothetical results section
                const existingHypotheticalSection = document.getElementById('hypothetical-results-section');
                if (existingHypotheticalSection) {
                    existingHypotheticalSection.remove();
                }
                
                // Create the section container
                const hypotheticalSection = document.createElement('div');
                hypotheticalSection.className = 'section-divider';
                hypotheticalSection.id = 'hypothetical-results-section';
                
                // Add heading
                const heading = document.createElement('h3');
                heading.textContent = 'Hypothetical Results';
                hypotheticalSection.appendChild(heading);
                
                // Add description
                const description = document.createElement('p');
                description.textContent = 'Add a hypothetical match result to see how it would affect the rankings:';
                hypotheticalSection.appendChild(description);
                
                // Create the selection controls
                const selectionDiv = document.createElement('div');
                selectionDiv.className = 'hypothetical-selection';
                
                // Create a table for layout
                const tableLayout = document.createElement('table');
                tableLayout.className = 'hypothetical-table';
                
                // Header row
                const headerRow = document.createElement('tr');
                
                const teamHeaderCell = document.createElement('th');
                teamHeaderCell.textContent = 'Team';
                headerRow.appendChild(teamHeaderCell);
                
                const scoreHeaderCell = document.createElement('th');
                scoreHeaderCell.textContent = 'Score';
                headerRow.appendChild(scoreHeaderCell);
                
                tableLayout.appendChild(headerRow);
                
                // Team A row
                const teamARow = document.createElement('tr');
                
                const teamACell = document.createElement('td');
                const teamASelect = document.createElement('select');
                teamASelect.id = 'hypo-team-a-select';
                teamACell.appendChild(teamASelect);
                teamARow.appendChild(teamACell);
                
                const scoreACell = document.createElement('td');
                const scoreASelect = document.createElement('select');
                scoreASelect.id = 'hypo-score-a-select';
                
                // Add score options (0-3)
                for (let i = 0; i <= 3; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = i;
                    scoreASelect.appendChild(option);
                }
                
                scoreACell.appendChild(scoreASelect);
                teamARow.appendChild(scoreACell);
                
                tableLayout.appendChild(teamARow);
                
                // Team B row
                const teamBRow = document.createElement('tr');
                
                const teamBCell = document.createElement('td');
                const teamBSelect = document.createElement('select');
                teamBSelect.id = 'hypo-team-b-select';
                teamBCell.appendChild(teamBSelect);
                teamBRow.appendChild(teamBCell);
                
                const scoreBCell = document.createElement('td');
                const scoreBSelect = document.createElement('select');
                scoreBSelect.id = 'hypo-score-b-select';
                
                // Add score options (0-3)
                for (let i = 0; i <= 3; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = i;
                    scoreBSelect.appendChild(option);
                }
                
                scoreBCell.appendChild(scoreBSelect);
                teamBRow.appendChild(scoreBCell);
                
                tableLayout.appendChild(teamBRow);
                
                selectionDiv.appendChild(tableLayout);
                
                // Generate button
                const generateButton = document.createElement('button');
                generateButton.id = 'generate-hypo-button';
                generateButton.textContent = 'Generate Rankings with Hypothetical Match';
                generateButton.className = 'generate-hypo-button';
                selectionDiv.appendChild(generateButton);
                
                hypotheticalSection.appendChild(selectionDiv);
                
                // Add event listeners for score validation
                scoreASelect.addEventListener('change', function() {
                    updateScoreOptions(scoreASelect, scoreBSelect);
                });
                
                scoreBSelect.addEventListener('change', function() {
                    updateScoreOptions(scoreBSelect, scoreASelect);
                });
                
                // Add the section to the results container
                document.getElementById('results').appendChild(hypotheticalSection);
                
                return hypotheticalSection;
            }
            
            // Function to update score options based on the other score
            function updateScoreOptions(selectedScoreDropdown, otherScoreDropdown) {
                const selectedScore = parseInt(selectedScoreDropdown.value);
                const maxOtherScore = 5 - selectedScore;
                
                // Update the other dropdown options
                Array.from(otherScoreDropdown.options).forEach(option => {
                    const optionValue = parseInt(option.value);
                    if (optionValue > maxOtherScore) {
                        option.disabled = true;
                        option.style.color = '#999';
                        option.style.backgroundColor = '#f5f5f5';
                    } else {
                        option.disabled = false;
                        option.style.color = '';
                        option.style.backgroundColor = '';
                    }
                });
                
                // If the current selection in the other dropdown is now invalid, adjust it
                if (parseInt(otherScoreDropdown.value) > maxOtherScore) {
                    otherScoreDropdown.value = maxOtherScore;
                }
            }

            // Function to populate team dropdowns for both predictor and hypothetical sections
            function populateTeamDropdowns(rankings, winlessTeams) {
                // Get all the team select dropdowns
                const teamSelects = [
                    document.getElementById('team-a-select'),
                    document.getElementById('team-b-select'),
                    document.getElementById('hypo-team-a-select'),
                    document.getElementById('hypo-team-b-select')
                ];
                
                // Clear existing options
                teamSelects.forEach(select => {
                    if (select) {
                        select.innerHTML = '';
                        
                        // Add an empty option first
                        const emptyOption = document.createElement('option');
                        emptyOption.value = '';
                        emptyOption.textContent = '-- Select a team --';
                        select.appendChild(emptyOption);
                    }
                });
                
                // Add ranked teams first
                rankings.forEach((team, index) => {
                    teamSelects.forEach(select => {
                        if (select) {
                            const option = document.createElement('option');
                            option.value = team.name;
                            option.textContent = `${team.name} (Rank: ${index + 1})`;
                            select.appendChild(option);
                        }
                    });
                });
                
                // Then add winless teams if available
                if (winlessTeams && winlessTeams.length > 0) {
                    // Add a divider
                    teamSelects.forEach(select => {
                        if (select) {
                            const divider = document.createElement('optgroup');
                            divider.label = 'Teams with no wins';
                            select.appendChild(divider);
                        }
                    });
                    
                    // Add each winless team
                    winlessTeams.forEach(team => {
                        teamSelects.forEach(select => {
                            if (select) {
                                const option = document.createElement('option');
                                option.value = team.name;
                                option.textContent = `${team.name} (No Wins)`;
                                select.appendChild(option);
                            }
                        });
                    });
                }
            }
            
            // Setup the hypothetical match button handler
            function setupHypotheticalHandler() {
                const generateHypoButton = document.getElementById('generate-hypo-button');
                
                if (generateHypoButton) {
                    generateHypoButton.addEventListener('click', () => {
                        const teamASelect = document.getElementById('hypo-team-a-select');
                        const teamBSelect = document.getElementById('hypo-team-b-select');
                        const scoreASelect = document.getElementById('hypo-score-a-select');
                        const scoreBSelect = document.getElementById('hypo-score-b-select');
                        
                        const teamAName = teamASelect.value;
                        const teamBName = teamBSelect.value;
                        const teamAScore = parseInt(scoreASelect.value);
                        const teamBScore = parseInt(scoreBSelect.value);
                        
                        // Validate selections
                        if (!teamAName || !teamBName) {
                            alert('Please select both teams.');
                            return;
                        }
                        
                        if (teamAName === teamBName) {
                            alert('Please select two different teams.');
                            return;
                        }
                        
                        if (isNaN(teamAScore) || isNaN(teamBScore)) {
                            alert('Please select valid scores for both teams.');
                            return;
                        }
                        
                        // Create a hypothetical match
                        const today = new Date();
                        const dateString = today.toISOString().split('T')[0]; // Format as YYYY-MM-DD
                        
                        const hypotheticalMatch = {
                            date: dateString,
                            teamA: teamAName,
                            teamASets: teamAScore,
                            teamB: teamBName,
                            teamBSets: teamBScore,
                            isHypothetical: true
                        };
                        
                        // Determine match format (best of 5, best of 3, etc.)
                        const totalSets = teamAScore + teamBScore;
                        if (teamAScore > 2 || teamBScore > 2) {
                            hypotheticalMatch.format = 5; // Best of 5
                        } else if (totalSets === 3) {
                            hypotheticalMatch.format = 3; // Best of 3
                        } else if (totalSets === 2) {
                            hypotheticalMatch.format = 2; // Two sets played
                        } else {
                            hypotheticalMatch.format = 1; // One set played
                        }
                        
                        // Add the hypothetical match to our storage array
                        hypotheticalMatches.push(hypotheticalMatch);
                        
                        // Log the hypothetical match
                        logDebug(`Added hypothetical match: ${teamAName} ${teamAScore} - ${teamBScore} ${teamBName} (${dateString})`);
                        
                        try {
                            // Trigger the generate button to recalculate rankings with the hypothetical match
                            generateBtn.click();
                        } catch (error) {
                            logDebug(`Error processing hypothetical match: ${error.message}`);
                                loadingDiv.style.display = 'none';
                                resultsDiv.style.display = 'block';
                            alert('Error processing hypothetical match. See debug log for details.');
                        }
                    });
                }
            }

            // Function to process data separately from loading
            function processData(matches, teamRecords, opponentRatings, teamWins, formatStats, weightBo5, weightBo3, weightTwo, weightOne, weightBo3Penalty, weightSos) {
                // This is similar to the existing data processing function in the fetch logic
                // Create an array of teams based on team records
                const teams = Object.keys(teamRecords).map(teamName => {
                    return {
                        name: teamName,
                        rating: 0, // Will be calculated by Colley method
                        record: teamRecords[teamName],
                        scheduleStrength: 0 // Will be calculated later
                    };
                });
                
                // Create weight factors
                const weightFactors = {
                    5: weightBo5,
                    '5split': weightBo5Split,
                    3: weightBo3,
                    2: weightTwo,
                    1: weightOne,
                    'bo3penalty': weightBo3Penalty, // Add penalty to weightFactors
                    sos: weightSos
                };
                
                // Calculate ratings using the Colley method
                calculateVolleyballRankings(teams, teamToIndex, matches, weightFactors);
                
                // Calculate schedule strength for each team
                calculateScheduleStrength(teams, opponentRatings, teamWins);
                
                // Calculate adjusted rankings with schedule strength weighting
                calculateAdjustedRankings(teams, teamWins, weightFactors);
                
                // Separate teams with no wins
                const teamsWithWins = teams.filter(team => team.record && team.record.wins > 0);
                const winlessTeams = teams.filter(team => !team.record || team.record.wins === 0);
                
                // Sort the teams with wins by adjusted rank
                teamsWithWins.sort((a, b) => {
                    const adjA = a.adjustedRank || Number.MAX_SAFE_INTEGER;
                    const adjB = b.adjustedRank || Number.MAX_SAFE_INTEGER;
                    return adjA - adjB;  // Sort by adjusted rank ascending
                });
                
                // Store current rankings for sorting
                currentRankings = teamsWithWins;
                currentWinlessTeams = winlessTeams;
                
                // Store teamWins globally for use during sorting
                globalTeamWins = teamWins;
                
                // Create a global team map
                globalTeamMap = {};
                teamsWithWins.forEach(team => {
                    globalTeamMap[team.name] = team;
                });
                winlessTeams.forEach(team => {
                    globalTeamMap[team.name] = team;
                });
                
                // Now that we have all the data, let's apply 5-set match adjustments
                apply5SetMatchAdjustments(matches, teamWins, teamsWithWins, weightFactors);
                
                // After 5-set adjustments, apply Best-of-3 adjustments
                applyBestOf3MatchAdjustments(matches, teamWins, teamsWithWins);
                
                // After Bo3 adjustments, apply undefeated team adjustments
                applyUndefeatedTeamAdjustments(teamWins, teamsWithWins);
                
                // Calculate normalized adjusted ratings based on the adjusted rankings
                calculateAdjustedRatings(teamsWithWins, weightFactors); // Pass weightFactors here
                
                // Display results
                displayRankings(currentRankings, teamWins, globalTeamMap, globalMatches);
                displayWinlessTeams(currentWinlessTeams);
                
                // Hide loading and show results
                loadingDiv.style.display = 'none';
                resultsDiv.style.display = 'block';
                
                logDebug(`Rankings calculation complete with hypothetical match!`, true);
            }

            // Update setupPredictionHandlers to also set up the hypothetical handler
            function setupPredictionHandlers() {
                const predictButton = document.getElementById('predict-button');
                
                predictButton.addEventListener('click', () => {
                const teamASelect = document.getElementById('team-a-select');
                const teamBSelect = document.getElementById('team-b-select');
                
                    const teamAName = teamASelect.value;
                    const teamBName = teamBSelect.value;
                    
                    // Validate selections
                    if (!teamAName || !teamBName) {
                        alert('Please select both teams.');
                        return;
                    }
                    
                    if (teamAName === teamBName) {
                        alert('Please select two different teams.');
                        return;
                    }
                    
                    // Get team objects
                    const teamA = globalTeamMap[teamAName];
                    const teamB = globalTeamMap[teamBName];
                    
                    if (!teamA || !teamB) {
                        alert('Team data not found. Please try again.');
                        return;
                    }
                    
                    // Calculate prediction
                    const probabilities = predictMatchOutcome(teamA, teamB);
                    
                    // Display results
                    displayPredictionResults(teamA, teamB, probabilities);
                });
                
                // Also set up the hypothetical match handler
                setupHypotheticalHandler();
            }

            // Function to calculate match prediction
            function predictMatchOutcome(teamA, teamB) {
                // Get the selected rating type
                const ratingTypeSelect = document.getElementById('rating-type-select');
                const ratingType = ratingTypeSelect ? ratingTypeSelect.value : 'adjusted'; // Default to adjusted if not specified
                
                // Determine which ratings to use based on selection
                let ratingA, ratingB;
                let actualRatingType = ratingType; // Track which rating type we actually end up using
                
                if (ratingType === 'adjusted') {
                    // Only use adjusted ratings if both teams have them defined
                    if (teamA.adjustedRating !== undefined && teamB.adjustedRating !== undefined) {
                        ratingA = teamA.adjustedRating;
                        ratingB = teamB.adjustedRating;
                    } else {
                        // Fall back to standard ratings if either team is missing adjusted ratings
                        ratingA = teamA.rating;
                        ratingB = teamB.rating;
                        actualRatingType = 'standard'; // Note that we fell back to standard
                    }
                } else {
                    // Standard rating type
                    ratingA = teamA.rating;
                    ratingB = teamB.rating;
                }
                
                const scalingFactor = 4; // Adjust this to control how strongly ratings affect outcome
                
                // Calculate probability of team A winning
                const probA = 1 / (1 + Math.pow(10, (ratingB - ratingA) * scalingFactor));
                
                // Return probabilities for both teams and the rating type used
                return {
                    teamA: probA,
                    teamB: 1 - probA,
                    ratingType: actualRatingType
                };
            }

            // Function to display prediction results
            function displayPredictionResults(teamA, teamB, probabilities) {
                const resultsDiv = document.getElementById('prediction-results');
                resultsDiv.innerHTML = '';
                
                // Create a container for the visualization
                const vizContainer = document.createElement('div');
                vizContainer.className = 'prediction-viz';
                
                // Previous match history
                const historyDiv = document.createElement('div');
                historyDiv.className = 'match-history';
                
                const historyTitle = document.createElement('h4');
                historyTitle.textContent = 'Previous Matchups:';
                historyDiv.appendChild(historyTitle);
                
                // Find previous matches between these teams
                const matchHistory = findMatchesBetweenTeams(globalMatches, teamA.name, teamB.name);
                
                if (matchHistory.length > 0) {
                    const historyList = document.createElement('ul');
                    
                    matchHistory.forEach(match => {
                        const historyItem = document.createElement('li');
                        if (match.teamA === teamA.name) {
                            historyItem.textContent = `${match.teamA} ${match.teamASets} - ${match.teamBSets} ${match.teamB}`;
                            if (match.teamASets > match.teamBSets) {
                                historyItem.classList.add('team-a-win');
                            } else if (match.teamBSets > match.teamASets) {
                                historyItem.classList.add('team-b-win');
                            }
                        } else {
                            historyItem.textContent = `${match.teamB} ${match.teamBSets} - ${match.teamASets} ${match.teamA}`;
                            if (match.teamBSets > match.teamASets) {
                                historyItem.classList.add('team-a-win');
                            } else if (match.teamASets > match.teamBSets) {
                                historyItem.classList.add('team-b-win');
                            }
                        }
                        historyList.appendChild(historyItem);
                    });
                    
                    historyDiv.appendChild(historyList);
                } else {
                    const noHistory = document.createElement('p');
                    noHistory.textContent = 'No previous matches found between these teams.';
                    historyDiv.appendChild(noHistory);
                }
                
                vizContainer.appendChild(historyDiv);
                
                // Create the prediction bar
                const predictionBar = document.createElement('div');
                predictionBar.className = 'prediction-bar';
                
                // Calculate percentages
                const teamAPercent = Math.round(probabilities.teamA * 100);
                const teamBPercent = Math.round(probabilities.teamB * 100);
                
                // Team A side of the bar
                const teamABar = document.createElement('div');
                teamABar.className = 'team-a-bar';
                teamABar.style.width = `${teamAPercent}%`;
                
                const teamALabel = document.createElement('div');
                teamALabel.className = 'team-label';
                teamALabel.textContent = `${teamA.name}: ${teamAPercent}%`;
                teamABar.appendChild(teamALabel);
                
                // Team B side of the bar
                const teamBBar = document.createElement('div');
                teamBBar.className = 'team-b-bar';
                teamBBar.style.width = `${teamBPercent}%`;
                
                const teamBLabel = document.createElement('div');
                teamBLabel.className = 'team-label';
                teamBLabel.textContent = `${teamB.name}: ${teamBPercent}%`;
                teamBBar.appendChild(teamBLabel);
                
                predictionBar.appendChild(teamABar);
                predictionBar.appendChild(teamBBar);
                
                vizContainer.appendChild(predictionBar);
                
                // Determine which ratings were used
                const ratingType = probabilities.ratingType || 'standard';
                const ratingLabel = ratingType === 'adjusted' ? 'Adjusted Rating' : 'Standard Rating';
                
                // Prepare a fallback note if needed
                let fallbackNote = '';
                if (ratingType === 'standard' && document.getElementById('rating-type-select').value === 'adjusted') {
                    fallbackNote = '<p class="small-note">(Adjusted ratings not available for one or both teams, using standard ratings instead)</p>';
                }
                
                // Add ratings explanation
                const explanation = document.createElement('div');
                explanation.className = 'prediction-explanation';
                explanation.innerHTML = `
                    <p>Prediction based on team ${ratingLabel.toLowerCase()}s:</p>
                    ${fallbackNote}
                    <ul>
                        <li>${teamA.name}: ${ratingType === 'adjusted' && teamA.adjustedRating !== undefined ? 
                             teamA.adjustedRating.toFixed(3) : teamA.rating.toFixed(3)}</li>
                        <li>${teamB.name}: ${ratingType === 'adjusted' && teamB.adjustedRating !== undefined ? 
                             teamB.adjustedRating.toFixed(3) : teamB.rating.toFixed(3)}</li>
                    </ul>
                    <p class="small-note">The prediction model uses team ${ratingLabel.toLowerCase()}s to estimate win probability.</p>
                `;
                
                vizContainer.appendChild(explanation);
                
                resultsDiv.appendChild(vizContainer);
                resultsDiv.style.display = 'block';
            }

            // Helper function to find matches between two specific teams
            function findMatchesBetweenTeams(matches, teamA, teamB) {
                return matches.filter(match => 
                    (match.teamA === teamA && match.teamB === teamB) || 
                    (match.teamA === teamB && match.teamB === teamA)
                );
            }

            // Add the favicon link in the document head
            function addFavicon() {
                // Check if favicon already exists
                if (!document.querySelector('link[rel="icon"]')) {
                    const faviconLink = document.createElement('link');
                    faviconLink.rel = 'icon';
                    faviconLink.href = 'cif.svg';
                    faviconLink.type = 'image/svg+xml';
                    document.head.appendChild(faviconLink);
                    
                    // Also add apple touch icon for iOS devices
                    const appleIcon = document.createElement('link');
                    appleIcon.rel = 'apple-touch-icon';
                    appleIcon.href = 'cif.svg';
                    document.head.appendChild(appleIcon);
                }
            }

            // Call the function on document load
            document.addEventListener('DOMContentLoaded', function() {
                // Add favicon
                addFavicon();
                
                // ... existing DOMContentLoaded code ...
            });

            // Let's redefine how we set up the click handlers to ensure they're properly attached
            function setupSortHandlers() {
                console.log('Setting up sort handlers for columns');
                
                // Get the column headers
                const ratingColumn = document.getElementById('rating-sort');
                const strColumn = document.getElementById('str-sort');
                const adjColumn = document.getElementById('adj-sort');
                
                console.log('Column elements:', {
                    rating: ratingColumn,
                    str: strColumn,
                    adj: adjColumn
                });
                
                // Remove any existing click listeners to avoid duplicates
                if (ratingColumn) {
                    ratingColumn.replaceWith(ratingColumn.cloneNode(true));
                    document.getElementById('rating-sort').addEventListener('click', function() {
                        console.log('Rating column clicked');
                        sortRankings('rating');
                    });
                }
                
                if (strColumn) {
                    strColumn.replaceWith(strColumn.cloneNode(true));
                    document.getElementById('str-sort').addEventListener('click', function() {
                        console.log('Schedule column clicked');
                        sortRankings('str');
                    });
                }
                
                if (adjColumn) {
                    adjColumn.replaceWith(adjColumn.cloneNode(true));
                    document.getElementById('adj-sort').addEventListener('click', function() {
                        console.log('Adj column clicked');
                        sortRankings('adj');
                    });
                }
            }

            // Function to handle 5-set match adjustments separately
            function apply5SetMatchAdjustments(matches, teamWins, rankings, weightFactors = {}) {
                logDebug(`Explicitly applying 5-set match adjustments for ${rankings.length} teams...`);
                
                // Get the split weight with fallback to 0.0 if not defined
                const splitWeight = weightFactors?.['5split'] !== undefined ? weightFactors['5split'] : 0.0;
                logDebug(`Using 5-set split series weight: ${splitWeight}`);
                
                // Count split series for debugging
                let splitSeriesFound = 0;
                
                // First, find all 5-set match wins directly from matches
                const fiveSetWins = {};
                const fiveSetLosses = {}; // New map to track 5-set losses
                let totalFiveSetMatches = 0;
                
                for (const match of matches) {
                    // Only process matches with format 5 (best of 5)
                    if (match.format === 5) {
                        totalFiveSetMatches++;
                        
                        // Process Team A wins
                        if (match.teamASets > match.teamBSets) {
                            if (!fiveSetWins[match.teamA]) {
                                fiveSetWins[match.teamA] = [];
                            }
                            fiveSetWins[match.teamA].push(match.teamB);
                            
                            // Record Team B's loss
                            if (!fiveSetLosses[match.teamB]) {
                                fiveSetLosses[match.teamB] = [];
                            }
                            fiveSetLosses[match.teamB].push(match.teamA);
                            
                            logDebug(`⚠️ Found 5-set win: ${match.teamA} beat ${match.teamB} (${match.teamASets}-${match.teamBSets})`);
                        }
                        // Process Team B wins
                        else if (match.teamBSets > match.teamASets) {
                            if (!fiveSetWins[match.teamB]) {
                                fiveSetWins[match.teamB] = [];
                            }
                            fiveSetWins[match.teamB].push(match.teamA);
                            
                            // Record Team A's loss
                            if (!fiveSetLosses[match.teamA]) {
                                fiveSetLosses[match.teamA] = [];
                            }
                            fiveSetLosses[match.teamA].push(match.teamB);
                            
                            logDebug(`⚠️ Found 5-set win: ${match.teamB} beat ${match.teamA} (${match.teamBSets}-${match.teamASets})`);
                        }
                    }
                }
                
                // Log summary
                logDebug(`⚠️ Total 5-set matches found directly: ${totalFiveSetMatches}`);
                
                // If no 5-set matches, just return
                if (totalFiveSetMatches === 0) {
                    return;
                }
                
                // Now process the adjustments
                // Start with teams sorted by their rating (default ranking)
                rankings.sort((a, b) => b.rating - a.rating);
                
                // Initialize all teams with their default ranks
                rankings.forEach((team, index) => {
                    if (!team.adjustedRank) {
                        team.adjustedRank = index + 1;
                    }
                });
                
                // Create a list of all 5-set match wins to process
                const adjustmentsToProcess = [];
                
                // For each team, record their 5-set wins
                for (const teamName in fiveSetWins) {
                    const beaten = fiveSetWins[teamName];
                    for (const beatenTeam of beaten) {
                        // Check if there's a reciprocal match (team also lost to the same team in 5 sets)
                        const hasReciprocalLoss = fiveSetLosses[teamName] && fiveSetLosses[teamName].includes(beatenTeam);
                        
                        if (hasReciprocalLoss) {
                            splitSeriesFound++;
                            logDebug(`⚠️ Split series detected: ${teamName} and ${beatenTeam} have both won 5-set matches against each other`);
                        }
                        
                        // Add to adjustments regardless - we'll handle split series in the processing stage
                        adjustmentsToProcess.push({
                            winner: teamName,
                            loser: beatenTeam,
                            isSplitSeries: hasReciprocalLoss
                        });
                    }
                }
                
                logDebug(`⚠️ Total 5-set match adjustments to process: ${adjustmentsToProcess.length}`);
                
                // First, apply each adjustment individually
                let totalAdjustments = 0;
                
                // Process each adjustment (without iteration)
                for (const adjustment of adjustmentsToProcess) {
                    const winner = rankings.find(team => team.name === adjustment.winner);
                    const loser = rankings.find(team => team.name === adjustment.loser);
                    
                    if (!winner || !loser) {
                        logDebug(`⚠️ Could not find winner ${adjustment.winner} or loser ${adjustment.loser} in rankings, skipping`);
                        continue;
                    }
                    
                    // Sort the rankings by their current adjusted rank
                    rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
                    
                    // Find the current positions
                    const loserIndex = rankings.findIndex(team => team.name === loser.name);
                    const winnerIndex = rankings.findIndex(team => team.name === winner.name);
                    
                    // Use the isSplitSeries flag from the adjustment object
                    const hasReciprocalLoss = adjustment.isSplitSeries;
                    
                    // Check for circular dependency only if it's NOT a split series.
                    // If it IS a split series, we ignore circular logic and always adjust.
                    const hasCircular = !hasReciprocalLoss ? hasCircularDependency(loser.name, winner.name, teamWins) : false;
                    
                    // Adjust if winner is below loser AND (it's a split series OR there's no circular dependency)
                    if (winnerIndex > loserIndex && (hasReciprocalLoss || !hasCircular)) {
                        logDebug(`⚠️ Processing 5-set adjustment: ${winner.name} (rank ${winnerIndex+1}) beat ${loser.name} (rank ${loserIndex+1}). Split: ${hasReciprocalLoss}, Circular (ignored if split): ${hasCircular}`);
                          
                        // Always target the position directly above the loser
                        const targetIndex = loserIndex;
                          
                        // Place winner directly above loser by assigning loser's rank
                        // Note: Ranks might become non-integers temporarily if loser had a fractional rank.
                        // Subsequent logic might need to handle potential rank collisions later.
                        winner.adjustedRank = rankings[targetIndex].adjustedRank;
                        winner.adjustedDueToFiveSet = true;
                        // Modify tooltip slightly for split series for clarity
                        winner.beatInFiveSet = hasReciprocalLoss ? `${loser.name} (Split Series)` : loser.name;
                        logDebug(`⚠️ Magnet Adjustment: ${winner.name} moved directly above ${loser.name} to rank ${winner.adjustedRank}`);
                        
                        // Increment ranks for teams between the target position and the winner's original position
                        for (let i = targetIndex; i < winnerIndex; i++) {
                            if (rankings[i].name !== winner.name) {
                                rankings[i].adjustedRank++;
                            }
                        }
                        
                        totalAdjustments++;
                        logDebug(`⚠️ Adjusted ${winner.name} ${hasReciprocalLoss ? 'partially ' : ''}to rank ${winner.adjustedRank}`);
                    } else if (winnerIndex < loserIndex) {
                        logDebug(`⚠️ No adjustment needed: ${winner.name} (rank ${winnerIndex+1}) already ranked above ${loser.name} (rank ${loserIndex+1})`);
                    } else {
                        logDebug(`⚠️ Cannot adjust due to circular dependency: ${winner.name} vs ${loser.name}`);
                    }
                }
                
                if (splitSeriesFound === 0) {
                    logDebug(`⚠️ No 5-set split series found in the dataset - split weight has no effect`);
                } else {
                    logDebug(`⚠️ Found ${splitSeriesFound} 5-set split series. Applied adjustments with ${splitWeight * 100}% weight`);
                }
                
                logDebug(`⚠️ Completed 5-set match adjustments. Total adjustments made: ${totalAdjustments}`);
                
                // Final sort by adjusted rank
                rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
            }

            // Function to handle undefeated team adjustments after 5-set adjustments
            function applyUndefeatedTeamAdjustments(teamWins, rankings) {
                logDebug(`Applying undefeated team adjustments after 5-set adjustments for ${rankings.length} teams...`);
                
                // Make sure rankings are sorted by current adjusted rank
                rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
                
                // Create a mapping of teams to their current adjusted ranks
                const teamToRank = {};
                rankings.forEach(team => {
                    teamToRank[team.name] = team.adjustedRank;
                });
                
                let undefeatedAdjustmentsCount = 0;
                
                // Process each team
                rankings.forEach(team => {
                    // Check if team is undefeated
                    if (team.record && team.record.losses === 0 && team.record.wins > 0) {
                        logDebug(`Processing undefeated team: ${team.name} (current rank: ${team.adjustedRank}, wins: ${team.record.wins})`);
                        
                        // Find the highest ranked team they've beaten
                        const teamsBeaten = teamWins[team.name] || [];
                        
                        if (teamsBeaten.length > 0) {
                            let bestBeatenRank = Number.MAX_SAFE_INTEGER;
                            let bestBeatenTeam = '';
                            
                            teamsBeaten.forEach(beatenTeam => {
                                const beatenRank = teamToRank[beatenTeam] || Number.MAX_SAFE_INTEGER;
                                if (beatenRank < bestBeatenRank) {
                                    bestBeatenRank = beatenRank;
                                    bestBeatenTeam = beatenTeam;
                                }
                            });
                            
                            // Adjust to be exactly one position above their best win
                            if (bestBeatenRank < Number.MAX_SAFE_INTEGER) {
                                const oldRank = team.adjustedRank;
                                const targetRank = bestBeatenRank - 1; // One position ABOVE the best team beaten
                                team.bestBeatenTeam = bestBeatenTeam; // Store this regardless of adjustment
                                
                                logDebug(`Undefeated team ${team.name} current rank: ${oldRank}, target rank: ${targetRank} (above ${bestBeatenTeam})`);
                                
                                // If current rank is better than needed (need to move down)
                                if (targetRank > oldRank) {
                                    // Only apply downward adjustment if team has fewer than 15 wins
                                    if (team.record.wins < 15) {
                                    logDebug(`⚠️ ADJUSTING undefeated team DOWN: ${team.name} from rank ${oldRank} to ${targetRank} (above best beaten team: ${bestBeatenTeam}, rank: ${bestBeatenRank})`);
                                    
                                    team.adjustedRank = targetRank;
                                    team.adjustedDueToUndefeated = true;
                                    
                                    // Move other teams up
                                    rankings.forEach(otherTeam => {
                                        if (otherTeam !== team && otherTeam.adjustedRank > oldRank && otherTeam.adjustedRank <= targetRank) {
                                            otherTeam.adjustedRank--;
                                            logDebug(`Moving ${otherTeam.name} up to rank ${otherTeam.adjustedRank} due to undefeated team moving down`);
                                        }
                                    });
                                    
                                    undefeatedAdjustmentsCount++;
                                    } else {
                                        logDebug(`⚠️ Skipping downward adjustment for undefeated team ${team.name} because it has ${team.record.wins} wins (≥ 15)`);
                                        // Still mark it as an undefeated team, but don't adjust
                                        team.adjustedDueToUndefeated = false;
                                        team.exemptedFromAdjustment = true;
                                    }
                                }
                                // If current rank is worse than needed (need to move up)
                                else if (targetRank < oldRank) {
                                    logDebug(`⚠️ ADJUSTING undefeated team UP: ${team.name} from rank ${oldRank} to ${targetRank} (above best beaten team: ${bestBeatenTeam}, rank: ${bestBeatenRank})`);
                                    
                                    team.adjustedRank = targetRank;
                                    team.adjustedDueToUndefeated = true;
                                    
                                    // Push other teams down
                                    rankings.forEach(otherTeam => {
                                        if (otherTeam !== team && otherTeam.adjustedRank >= targetRank && otherTeam.adjustedRank < oldRank) {
                                            otherTeam.adjustedRank++;
                                            logDebug(`Pushing ${otherTeam.name} down to rank ${otherTeam.adjustedRank} due to undefeated team moving up`);
                                        }
                                    });
                                    
                                    undefeatedAdjustmentsCount++;
                                }
                                // If already at correct rank
                                else {
                                    logDebug(`Undefeated team ${team.name} already at correct rank (${oldRank}), no adjustment needed`);
                                    // Still mark it as adjusted for display purposes
                                    team.adjustedDueToUndefeated = true;
                                }
                            }
                        } else {
                            logDebug(`Undefeated team ${team.name} has no wins recorded, can't adjust`);
                        }
                    }
                });
                
                logDebug(`Completed undefeated team adjustments. Total adjustments made: ${undefeatedAdjustmentsCount}`);
                
                // Log all undefeated teams to debug
                const undefeatedTeams = rankings.filter(team => team.record && team.record.losses === 0 && team.record.wins > 0);
                logDebug(`Total undefeated teams: ${undefeatedTeams.length}`);
                undefeatedTeams.forEach(team => {
                    const status = team.exemptedFromAdjustment ? 'exempted (15+ wins)' : (team.adjustedDueToUndefeated ? 'adjusted' : 'not adjusted');
                    logDebug(`Undefeated team: ${team.name}, status: ${status}, wins: ${team.record.wins}, adjustedRank: ${team.adjustedRank}`);
                });
                
                // Final sort by adjusted rank
                rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
            }

            // Function to fix indicator placement
            function fixIndicatorPlacement(showIndicators = null) {
                // If showIndicators wasn't explicitly passed, default to checking the sort state
                if (showIndicators === null) {
                    showIndicators = sortState.column === 'adj';
                }
                
                // Target all rows in the rankings table
                document.querySelectorAll('#rankings-table tbody tr').forEach(row => {
                    const cells = row.querySelectorAll('td');
                    
                    // Skip if row doesn't have enough cells
                    if (cells.length < 5) return;
                    
                    // Get the Adj cell
                    const adjCell = cells[4];
                    
                    // If not showing indicators, clear and set to dash
                    if (!showIndicators && adjCell) {
                        adjCell.textContent = '-';
                        adjCell.className = '';
                        adjCell.removeAttribute('title');
                        return;
                    }
                    
                    // If sorting by Adj but cell is empty, set to dash
                    if (showIndicators && adjCell && !adjCell.textContent) {
                        adjCell.textContent = '-';
                    }
                    
                    // Ensure Rating cell has correct format
                    const ratingCell = cells[2];
                    if (ratingCell && ratingCell.textContent !== '-') {
                        try {
                            // Extract just the number and format to 4 decimal places
                            const ratingValue = parseFloat(ratingCell.textContent.replace(/[^0-9.]/g, ''));
                            if (!isNaN(ratingValue)) {
                                ratingCell.textContent = ratingValue.toFixed(3);
                            }
                        } catch (e) {
                            console.error('Error formatting rating cell:', e);
                        }
                    }
                    
                    // Ensure Schedule cell has correct format
                    const scheduleCell = cells[3];
                    if (scheduleCell) {
                        if (scheduleCell.textContent.toLowerCase().includes('n/a')) {
                            scheduleCell.textContent = 'N/A';
                        } else if (scheduleCell.textContent !== '-') {
                            try {
                                const scheduleValue = parseFloat(scheduleCell.textContent.replace(/[^0-9.]/g, ''));
                                if (!isNaN(scheduleValue)) {
                                    scheduleCell.textContent = scheduleValue.toFixed(3);
                                }
                            } catch (e) {
                                console.error('Error formatting schedule cell:', e);
                            }
                        }
                    }
                });
            }

            // Function to calculate normalized ratings based on adjusted ranks
            function calculateAdjustedRatings(rankings, weightFactors) {
                // First, sort the teams by their adjusted rank
                rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
                
                logDebug(`Calculating adjusted ratings based directly on adjusted ranks for ${rankings.length} teams`);
                
                // Assign adjusted ratings based on position in the adjusted rankings
                // Teams at the top (lower adjustedRank) get higher adjustedRating values
                const totalTeams = rankings.length;
                const penaltyValue = weightFactors?.bo3penalty !== undefined ? weightFactors.bo3penalty : 0.02; // Get penalty from weights, default 0.02
                
                rankings.forEach((team, index) => {
                    // Calculate the base normalized position (0 to 1 scale, where 1 is the best team)
                    // Avoid division by zero if only one team
                    const normalizedPosition = totalTeams > 1 ? 1 - (index / (totalTeams - 1)) : 1;
                    
                    // Scale to a nice 0.05 to 0.99 range initially
                    team.adjustedRating = 0.05 + (normalizedPosition * 0.94);

                    // Apply penalty if flagged for a Bo3 loss
                    if (team.penalizedDueToBo3Loss) {
                        const initialAdjRating = team.adjustedRating; // Store before penalty
                        team.adjustedRating -= penaltyValue;
                        logDebug(`  ${team.name}: Applying Bo3 loss penalty (-${penaltyValue}). Rating before: ${initialAdjRating.toFixed(3)}, after: ${team.adjustedRating.toFixed(3)}`);
                        // ** REMOVED CLAMPING AT 0.05, ADDED CLAMP AT 0 **
                        if (team.adjustedRating < 0) {
                             team.adjustedRating = 0; // Clamp at 0 instead of 0.05
                             logDebug(`   Rating clamped at 0.000`);
                        }
                    }
                    
                    // Find position in the original rankings
                    const originalRankingSorted = [...rankings].sort((a, b) => b.rating - a.rating);
                    const originalIndex = originalRankingSorted.findIndex(t => t.name === team.name);
                    
                    // Calculate position change (positive means moved up, negative means moved down)
                    const positionChange = originalIndex - index;
                    
                    // Log the adjustment if significant
                    if (Math.abs(positionChange) > 0) {
                        logDebug(`${team.name}: Rank ${index+1}, Original rank ${originalIndex+1}, ` +
                                 `Rating ${team.rating.toFixed(3)}, Adjusted to ${team.adjustedRating.toFixed(3)} ` +
                                 `(moved ${positionChange > 0 ? 'up' : 'down'} ${Math.abs(positionChange)} positions)`);
                    }
                });
                
                // Log the first few teams to verify proper ordering
                logDebug(`Top teams with adjusted ratings:`);
                for (let i = 0; i < Math.min(10, rankings.length); i++) {
                    logDebug(`  ${i+1}. ${rankings[i].name}: ${rankings[i].adjustedRating.toFixed(3)}`);
                }
                
                // ** Store pre-league adjustment ratings for conditional logic **
                // Assign to the hoisted variable instead of declaring a new one
                preLeagueAdjRatings = {}; 
                rankings.forEach(team => {
                    preLeagueAdjRatings[team.name] = team.adjustedRating;
                });
                logDebug("Stored pre-league adjustment ratings.");

                // ** APPLY COMPREHENSIVE LEAGUE RANK REORDERING **
                logDebug(`Applying comprehensive league rank reordering for ${rankings.length} teams...`);
                
                // Group teams by league, only including those with a league and numeric leagueRank
                const teamsByLeague = {};
                rankings.forEach((team, index) => {
                    if (team.league && typeof team.leagueRank === 'number') {
                        if (!teamsByLeague[team.league]) {
                            teamsByLeague[team.league] = [];
                        }
                        // Store team object and its current index
                        teamsByLeague[team.league].push({ team: team, originalIndex: index }); 
                    }
                });
                
                let leagueAdjustmentsCount = 0;
                const fiveSetWins = findFiveSetMatchWins(globalMatches || []); // Needed for split check
                
                // Process each league that has 2 or more teams
                for (const league in teamsByLeague) {
                    const leagueGroupItems = teamsByLeague[league];
                    
                    if (leagueGroupItems.length < 2) {
                        continue; // Skip leagues with only one team
                    }
                    
                    logDebug(`Processing league: ${league} with ${leagueGroupItems.length} teams`);
                    
                    // Extract the current adjusted ratings for this league group (use pre-league stored ratings)
                    const currentRatingsPool = leagueGroupItems
                        .map(item => preLeagueAdjRatings[item.team.name]) // Use the stored pre-league ratings
                        .sort((a, b) => b - a); // Sort ratings descending
                    logDebug(` Pre-league ratings pool for ${league}: ${currentRatingsPool.map(r => r.toFixed(3)).join(', ')}`);
                    
                    // Sort the teams within this league group strictly by their leagueRank
                    leagueGroupItems.sort((a, b) => a.team.leagueRank - b.team.leagueRank); // Sort teams by leagueRank ascending
                    
                    const handledTeams = new Set(); // Track teams handled by the special split rule
                    const assignedRatings = {}; // Store final ratings assigned in this block

                    // --- First Pass: Handle Special Split Scenario --- 
                    logDebug(` League ${league}: Checking for special split scenarios...`);
                    for (let i = 0; i < leagueGroupItems.length; i++) {
                        for (let j = i + 1; j < leagueGroupItems.length; j++) {
                            const itemA = leagueGroupItems[i]; // Better league rank
                            const itemB = leagueGroupItems[j]; // Worse league rank
                            const teamA = itemA.team;
                            const teamB = itemB.team;

                            // Check for 5-set split
                            const aWonBo5 = fiveSetWins[teamA.name]?.includes(teamB.name);
                            const bWonBo5 = fiveSetWins[teamB.name]?.includes(teamA.name);

                            if (aWonBo5 && bWonBo5) {
                                logDebug(`  Split detected: ${teamA.name} (L#${teamA.leagueRank}) vs ${teamB.name} (L#${teamB.leagueRank})`);
                                // Check if higher league rank team (A) was rated lower *before* league adjustments
                                const preRatingA = preLeagueAdjRatings[teamA.name];
                                const preRatingB = preLeagueAdjRatings[teamB.name];
                                logDebug(`    Pre-league ratings: ${teamA.name}=${preRatingA.toFixed(3)}, ${teamB.name}=${preRatingB.toFixed(3)}`);

                                if (preRatingA < preRatingB) {
                                    // *** Apply the User's Proposed Logic ***
                                    logDebug(`    SPECIAL CASE TRIGGERED: ${teamA.name} (L#${teamA.leagueRank}) keeps pre-league rating. ${teamB.name} magneted below.`);
                                    
                                    // Team A keeps its pre-league rating
                                    assignedRatings[teamA.name] = preRatingA;
                                    handledTeams.add(teamA.name);
                                    teamA.adjustedDueToSplitOverride = true; // Flag for info

                                    // Team B is magneted below Team A
                                    const epsilon = 1e-6;
                                    assignedRatings[teamB.name] = preRatingA - epsilon;
                                    handledTeams.add(teamB.name);
                                    teamB.adjustedDueToSplitMagnet = true; // Reuse magnet flag
                                    teamB.magnetPartner = teamA.name;
                                    
                                    leagueAdjustmentsCount++;
                                    // Skip further checks for this pair once handled
                                    // Note: This assumes a pair only triggers once. If A vs B and B vs C could trigger, this might need refinement.
                                } else {
                                     logDebug(`    Split found, but ${teamA.name} (L#${teamA.leagueRank}) was already rated higher. Normal league assignment applies.`);
                                }
                            }
                        }
                    }

                    // --- Second Pass: Assign ratings to remaining teams --- 
                    logDebug(` League ${league}: Assigning remaining ratings...`);
                    // Create a mutable copy of the ratings pool
                    const remainingRatingsPool = [...currentRatingsPool]; 
                    
                    // Create a list of ratings to remove based on handled teams' pre-league ratings
                    const handledRatingsToRemove = [];
                    handledTeams.forEach(handledTeamName => {
                        handledRatingsToRemove.push(preLeagueAdjRatings[handledTeamName]);
                    });

                    // Filter out the handled ratings from the pool, handling potential duplicates correctly
                    const finalRatingsPool = remainingRatingsPool.filter(rating => {
                        const indexToRemove = handledRatingsToRemove.findIndex(handledRating => Math.abs(rating - handledRating) < 1e-9);
                        if (indexToRemove > -1) {
                            // Remove the found rating from the removal list so duplicates aren't removed multiple times
                            handledRatingsToRemove.splice(indexToRemove, 1);
                            return false; // Exclude this rating
                        }
                        return true; // Keep this rating
                    });

                    logDebug(`  Ratings pool after removing handled teams: ${finalRatingsPool.map(r => r.toFixed(3)).join(', ')}`);

                    let poolIndex = 0;
                    leagueGroupItems.forEach(item => {
                        const team = item.team;
                        // If team wasn't handled by the special rule, assign from the remaining pool
                        if (!handledTeams.has(team.name)) {
                            if (poolIndex < finalRatingsPool.length) {
                                const newRating = finalRatingsPool[poolIndex];
                                assignedRatings[team.name] = newRating;
                                logDebug(`  Assigning normal rating ${newRating.toFixed(3)} to ${team.name} (L#${team.leagueRank}) from pool index ${poolIndex}`);
                                poolIndex++;
                                // Check if rating actually changed compared to pre-league rating for counting adjustments
                                if (Math.abs(preLeagueAdjRatings[team.name] - newRating) > 1e-9) {
                                   leagueAdjustmentsCount++;
                                }
                            } else {
                                // Should not happen if logic is correct, but log error if it does
                                logDebug(`  ERROR: Rating pool exhausted for ${team.name}. Keeping pre-league rating ${preLeagueAdjRatings[team.name].toFixed(3)}.`);
                                assignedRatings[team.name] = preLeagueAdjRatings[team.name]; // Keep pre-league as fallback
                            }
                        }
                    });

                    // --- Third Pass: Apply the calculated ratings --- 
                    leagueGroupItems.forEach(item => {
                         const team = item.team;
                         if (assignedRatings[team.name] !== undefined) {
                             // Only update if the assigned rating is different from the existing one
                             if (Math.abs(team.adjustedRating - assignedRatings[team.name]) > 1e-9) {
                                logDebug(` Applying final rating ${assignedRatings[team.name].toFixed(3)} to ${team.name}`);
                                team.adjustedRating = assignedRatings[team.name];
                                // Determine final adjustment flags based on comparison to preLeagueAdjRatings
                                if (team.adjustedRating > preLeagueAdjRatings[team.name] + 1e-9) {
                                    team.adjustedDueToLeague = true; // Moved up by league rule
                                    team.adjustedDownDueToLeague = false;
                                } else if (team.adjustedRating < preLeagueAdjRatings[team.name] - 1e-9) {
                                    team.adjustedDownDueToLeague = true; // Moved down by league rule
                                    team.adjustedDueToLeague = false;
                                } else {
                                     // Rating ended up same as pre-league, clear flags unless handled by split rule
                                     if (!handledTeams.has(team.name)) {
                                         team.adjustedDueToLeague = false;
                                         team.adjustedDownDueToLeague = false;
                                     }
                                }
                             } else if (!handledTeams.has(team.name)) {
                                // Rating didn't change and not handled by split rule, clear league flags
                                team.adjustedDueToLeague = false;
                                team.adjustedDownDueToLeague = false;
                             }
                         }
                    });
                }
                
                logDebug(`Completed league block rating assignments. Total adjustments recorded: ${leagueAdjustmentsCount}`);
                
                // ** FINAL SORT by potentially updated adjustedRating **
                rankings.sort((a, b) => b.adjustedRating - a.adjustedRating);

                // ** SET FINAL LEAGUE ADJUSTMENT FLAGS (for display) **
                // Iterate through the *final sorted* list to set flags based on adjacent teams in the same league
                logDebug("Setting final league adjustment display flags based on final sorted order...");
                for (let i = 0; i < rankings.length - 1; i++) {
                   const teamA = rankings[i];
                   const teamB = rankings[i+1];
                   
                   // Only set flags if an adjustment actually occurred for one of the teams
                   if ((teamA.wasAdjustedByLeague || teamB.wasAdjustedByLeague) && 
                       teamA.league && teamA.league === teamB.league &&
                       typeof teamA.leagueRank === 'number' && typeof teamB.leagueRank === 'number') {
                           
                       if (teamA.leagueRank > teamB.leagueRank) {
                           // teamA (higher overall) has WORSE league rank than teamB (lower overall)
                           // This means teamA was effectively moved down relative to teamB by the league logic
                           teamA.adjustedDownDueToLeague = true;
                           teamA.movedDownFor = teamB.name;
                           // teamB was effectively moved up relative to teamA
                           teamB.adjustedDueToLeague = true;
                           teamB.leaguePositionOver = teamA.name;
                           logDebug(`  Flagging: ${teamA.name} (down, L#${teamA.leagueRank}) vs ${teamB.name} (up, L#${teamB.leagueRank})`);
                       }
                   }
                }
                
                logDebug(`Completed adjusted rating calculation - Higher values indicate better teams`);
            }

            // Add the new function at an appropriate place later in the file
            function ensureScheduleStrengthDisplay() {
                logDebug(`Ensuring correct schedule strength values are displayed with tooltips...`);
                
                // Find all schedule strength cells in the main rankings table
                const strengthCells = document.querySelectorAll('#rankings-table tbody tr td:nth-child(4)');
                
                // First, make sure we rebuild all strength cells from scratch to ensure consistency
                strengthCells.forEach((cell, index) => {
                    if (index < currentRankings.length) {
                        const team = currentRankings[index];
                        
                        // Always rebuild the cell completely to ensure consistency
                        if (team) {
                            // Clear the cell content first
                            cell.textContent = '';
                            cell.className = '';
                            
                            // Create a span for the strength value that can have a tooltip
                            const strengthValueSpan = document.createElement('span');
                            strengthValueSpan.textContent = team.scheduleStrength ? team.scheduleStrength.toFixed(3) : 'N/A';
                            strengthValueSpan.className = 'record-hover'; // Add hover class for tooltip
                            
                            if (team.scheduleStrength) {
                                // Prepare tooltip text explaining the weighted calculation
                                let tooltipText = `Top Opponents:\n${team.topOpponents || 'None'}\n`;

                               
                                // Add tooltip functionality
                                strengthValueSpan.dataset.tooltip = tooltipText;
                                strengthValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                                strengthValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                            }
                            
                            // Add the span to the cell
                            cell.appendChild(strengthValueSpan);
                        }
                    }
                });
                
                // Also update winless teams if any
                const winlessStrengthCells = document.querySelectorAll('#winless-teams-table tbody tr td:nth-child(3)');
                
                winlessStrengthCells.forEach((cell, index) => {
                    if (index < currentWinlessTeams.length) {
                        const team = currentWinlessTeams[index];
                        
                        // Always rebuild the cell completely to ensure consistency
                        if (team) {
                            // Clear the cell content first
                            cell.textContent = '';
                            cell.className = '';
                            
                            // Create a span for the strength value that can have a tooltip
                            const strengthValueSpan = document.createElement('span');
                            strengthValueSpan.textContent = team.scheduleStrength ? team.scheduleStrength.toFixed(3) : 'N/A';
                            strengthValueSpan.className = 'record-hover'; // Add hover class for tooltip
                            
                            if (team.scheduleStrength) {
                                // Prepare tooltip text explaining the weighted calculation
                                let tooltipText = `Top Opponents:\n${team.topOpponents || 'None'}\n`;
                                
                                
                                // Add tooltip functionality
                                strengthValueSpan.dataset.tooltip = tooltipText;
                                strengthValueSpan.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                                strengthValueSpan.addEventListener('mouseleave', handleTooltipMouseLeave);
                            }
                            
                            // Add the span to the cell
                            cell.appendChild(strengthValueSpan);
                        }
                    }
                });
                
                // Also update the league strength table if it exists
                const leagueStrengthCells = document.querySelectorAll('#league-strength-table tbody tr td:nth-child(2)');
                
                leagueStrengthCells.forEach((cell, index) => {
                    // Check if this cell contains a numeric value (not a dash)
                    if (cell.textContent !== '-' && !isNaN(parseFloat(cell.textContent))) {
                        // Ensure it's displayed with 3 decimal places
                        const value = parseFloat(cell.textContent);
                        cell.textContent = value.toFixed(3);
                    }
                });
                
                logDebug(`Schedule strength values have been updated in all tables with tooltips.`);
            }

            // Add a function to initialize all tooltips
            function initializeAllTooltips() {
                logDebug(`Initializing all tooltips...`);
                
                // Find all elements with tooltip classes
                const tooltipElements = document.querySelectorAll('.record-hover, .league-rank, [data-tooltip]');
                
                // Make sure all tooltip elements have the right event listeners
                tooltipElements.forEach(element => {
                    if (element.classList.contains('record-hover') || element.hasAttribute('data-tooltip')) {
                        // Remove any existing event listeners to avoid duplicates
                        element.removeEventListener('mouseenter', handleTooltipMouseEnter);
                        element.removeEventListener('mouseenter', handleAdjTooltipMouseEnter);
                        element.removeEventListener('mouseleave', handleTooltipMouseLeave);
                        
                        // Determine if this is a schedule strength tooltip
                        // Check if it's in the 4th column of the main table (schedule strength)
                        // or the 3rd column of the winless teams table
                        const isScheduleColumn = 
                            (element.closest('td:nth-child(4)') && element.closest('#rankings-table')) || 
                            (element.closest('td:nth-child(3)') && element.closest('#winless-teams-table'));
                        
                        // Add the appropriate event listener based on the type
                        if (isScheduleColumn) {
                            // Use left-side positioning for schedule tooltips
                            element.addEventListener('mouseenter', handleAdjTooltipMouseEnter);
                            logDebug(`Applied left-side tooltip to schedule element`);
                        } else {
                            // Use standard positioning for other tooltips
                            element.addEventListener('mouseenter', handleTooltipMouseEnter);
                        }
                        
                        // All tooltips use the same mouseleave handler
                        element.addEventListener('mouseleave', handleTooltipMouseLeave);
                    }
                });
                
                logDebug(`Initialized tooltips for ${tooltipElements.length} elements`);
            }
            
            // Call this function after page load
            window.addEventListener('load', function() {
                // Initialize tooltips after a slight delay to ensure DOM is fully rendered
                setTimeout(initializeAllTooltips, 200);
                
                // Two-step sort initialization to ensure schedule tooltips are initialized
                // but the final display is sorted by the desired column (adj)
                setTimeout(() => {
                    // Only do this if the rankings exist (i.e., if the user has generated rankings)
                    if (currentRankings && currentRankings.length > 0) {
                        logDebug("Initializing tooltips with two-step sort process");
                        
                        // First ensure we're sorted by schedule to initialize those tooltips
                        if (sortState.column !== 'str') {
                            // Store the current sort state
                            const originalSortState = {...sortState};
                            
                            // Temporarily sort by schedule
                            sortState.column = 'str';
                            sortState.direction = 'desc';
                            updateSortIndicator();
                            
                            // Re-display with schedule sort to initialize tooltips
                            displayRankings(currentRankings, globalTeamWins, globalTeamMap, globalMatches);
                            ensureScheduleStrengthDisplay();
                            initializeAllTooltips();
                            
                            // Now switch back to the original sort after a brief delay
                            setTimeout(() => {
                                sortState.column = originalSortState.column;
                                sortState.direction = originalSortState.direction;
                                updateSortIndicator();
                                
                                // Re-display with original sort
                                displayRankings(currentRankings, globalTeamWins, globalTeamMap, globalMatches);
                                fixIndicatorPlacement(sortState.column === 'adj');
                                ensureScheduleStrengthDisplay();
                                initializeAllTooltips();
                                
                                logDebug(`Completed two-step sort initialization. Final sort: ${sortState.column}`);
                            }, 300);
                        }
                    }
                }, 300);
            });
            
            // Also add it right after ensureScheduleStrengthDisplay in the initial rankings display
            // ...existing code...
            
            // Function to update dropdown options based on available sheets
            function updateDropdownOptions(sheetNames) {
                // Arrays to track available genders and years
                const availableGenders = [];
                const availableYears = [];
                
                // Check which genders are available
                if (sheetNames.some(name => name.includes('Boys'))) {
                    availableGenders.push('Boys');
                }
                if (sheetNames.some(name => name.includes('Girls'))) {
                    availableGenders.push('Girls');
                }
                
                // Check which years are available
                if (sheetNames.some(name => name.includes('Current Year'))) {
                    availableYears.push('Current Year');
                }
                
                // Check for specific years
                const yearOptions = [
                    '2023-24', '2022-23', '2021-22', '2020-21', '2019-20',
                    '2018-19', '2017-18', '2016-17', '2015-16', '2014-15',
                    '2013-14', '2012-13', '2011-12', '2010-11', '2009-10',
                    '2008-09', '2007-08', '2006-07', '2005-06', '2004-05'
                ];
                
                yearOptions.forEach(year => {
                    if (sheetNames.some(name => name.includes(year))) {
                        availableYears.push(year);
                    }
                });
                
                logDebug(`Available genders: ${availableGenders.join(', ')}`);
                logDebug(`Available years: ${availableYears.join(', ')}`);
                
                // Update gender dropdown
                const genderSelect = document.getElementById('gender-select');
                Array.from(genderSelect.options).forEach(option => {
                    option.disabled = !availableGenders.includes(option.value);
                });
                
                // If current selection is disabled, select the first available option
                if (genderSelect.selectedOptions[0].disabled && availableGenders.length > 0) {
                    genderSelect.value = availableGenders[0];
                }
                
                // Update year dropdown
                const yearSelect = document.getElementById('year-select');
                Array.from(yearSelect.options).forEach(option => {
                    option.disabled = !availableYears.includes(option.value);
                });
                
                // If current selection is disabled, select the first available option
                if (yearSelect.selectedOptions[0].disabled && availableYears.length > 0) {
                    yearSelect.value = availableYears[0];
                }
            }

            // Function to reorder adjacent teams in the same league based on their league position
            function applyLeagueRankReorder(rankings) {
                logDebug(`Applying comprehensive league rank reordering for ${rankings.length} teams...`);
                
                // Group teams by league
                const teamsByLeague = {};
                rankings.forEach(team => {
                    if (team.league && typeof team.leagueRank === 'number') {
                    if (!teamsByLeague[team.league]) {
                        teamsByLeague[team.league] = [];
                    }
                    teamsByLeague[team.league].push(team);
                    }
                });
                
                let leagueAdjustmentsCount = 0;
                
                // Process each league independently
                for (const league in teamsByLeague) {
                    const leagueTeams = teamsByLeague[league];
                    logDebug(`Processing league: ${league} with ${leagueTeams.length} teams`);
                    
                    // Get current adjusted ranks for these teams
                    const currentAdjustedRanks = leagueTeams.map(t => t.adjustedRank).sort((a, b) => a - b);
                    logDebug(` Current adjusted ranks for ${league}: ${currentAdjustedRanks.join(', ')}`);
                    
                    // Sort the teams within this league strictly by their leagueRank
                    leagueTeams.sort((a, b) => a.leagueRank - b.leagueRank);
                    
                    // Assign the sorted adjusted ranks back to the teams based on league order
                    leagueTeams.forEach((team, index) => {
                        const newRank = currentAdjustedRanks[index];
                        if (team.adjustedRank !== newRank) {
                            logDebug(`  Adjusting ${team.name} (League Rank: ${team.leagueRank}) from adjRank ${team.adjustedRank.toFixed(4)} to ${newRank.toFixed(4)}`);
                            
                            // Determine if moved up or down relative to league peers
                            // Find original position within the league block based on rank before this function ran
                            // Note: This relative check is tricky, focus on setting flags based on final order.
                            
                            team.adjustedRank = newRank;
                            leagueAdjustmentsCount++;
                            
                            // Reset previous league adjustment flags
                            team.adjustedDueToLeague = false;
                            team.adjustedDownDueToLeague = false;
                            team.leaguePositionOver = null;
                            team.movedDownFor = null;
                            
                            // We set flags later based on final relative positions
                        } else {
                            logDebug(`  ${team.name} (League Rank: ${team.leagueRank}) remains at adjRank ${team.adjustedRank.toFixed(4)}`);
                        }
                    });
                }
                
                logDebug(`Completed initial league rank assignment. Total adjustments: ${leagueAdjustmentsCount}`);
                
                // Final sort of all teams by potentially updated adjusted ranks
                rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
                
                // Resolve potential rank collisions introduced by forcing league order
                logDebug("Resolving potential rank collisions after league reordering...");
                let collisionResolvedCount = 0;
                for (let i = 0; i < rankings.length - 1; i++) {
                    if (Math.abs(rankings[i].adjustedRank - rankings[i+1].adjustedRank) < 1e-9) { // Check for effective equality
                        logDebug(`  Collision detected between ${rankings[i].name} (Rank ${rankings[i].adjustedRank}) and ${rankings[i+1].name} (Rank ${rankings[i+1].adjustedRank})`);
                        // Prioritize team with better league rank if they are in the same league
                        let higherPriorityTeam = rankings[i];
                        let lowerPriorityTeam = rankings[i+1];
                        
                        if (higherPriorityTeam.league && higherPriorityTeam.league === lowerPriorityTeam.league && 
                            typeof higherPriorityTeam.leagueRank === 'number' && typeof lowerPriorityTeam.leagueRank === 'number' &&
                            higherPriorityTeam.leagueRank > lowerPriorityTeam.leagueRank) {
                                // Swap if team i has worse league rank but ended up tied/slightly higher
                                [higherPriorityTeam, lowerPriorityTeam] = [lowerPriorityTeam, higherPriorityTeam];
                                logDebug(`    Prioritizing ${higherPriorityTeam.name} due to better league rank.`);
                        }
                        // Slightly adjust the rank of the lower priority team
                        lowerPriorityTeam.adjustedRank += 1e-5; // Add a small delta
                        collisionResolvedCount++;
                        logDebug(`    Adjusted ${lowerPriorityTeam.name}'s rank slightly to ${lowerPriorityTeam.adjustedRank.toFixed(5)}`);
                    }
                }
                
                // Re-sort after collision resolution
                if (collisionResolvedCount > 0) {
                    logDebug(`Resolved ${collisionResolvedCount} collisions. Re-sorting...`);
                    rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
                }
                
                // Now set the final display flags based on relative positions *within the same league*
                logDebug("Setting final league adjustment display flags...");
                for (let i = 0; i < rankings.length - 1; i++) {
                   const teamA = rankings[i];
                   const teamB = rankings[i+1];
                   
                   if (teamA.league && teamA.league === teamB.league &&
                       typeof teamA.leagueRank === 'number' && typeof teamB.leagueRank === 'number') {
                           
                       if (teamA.leagueRank > teamB.leagueRank) {
                           // teamA (higher overall) has WORSE league rank than teamB (lower overall)
                           // This means teamA was effectively moved down relative to teamB
                           teamA.adjustedDownDueToLeague = true;
                           teamA.movedDownFor = teamB.name;
                           // teamB was effectively moved up relative to teamA
                           teamB.adjustedDueToLeague = true;
                           teamB.leaguePositionOver = teamA.name;
                           logDebug(`  Flagging: ${teamA.name} (down) vs ${teamB.name} (up)`);
                       }
                   }
                }
                
                logDebug(`League reordering process complete.`);
                
                // Final sort is done implicitly by subsequent steps or should be called after this function if needed.
            }

            // Function to apply Best-of-3 match adjustments
            function applyBestOf3MatchAdjustments(matches, teamWins, rankings) {
                logDebug(`Applying Best-of-3 match adjustments for ${rankings.length} teams...`);
                
                // Make sure rankings are sorted by their current adjusted rank (reflecting 5-set adjustments)
                rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
                
                // Get Best-of-3 wins
                const bestOf3Wins = findBestOf3MatchWins(matches);
                const fiveSetWins = findFiveSetMatchWins(matches); // Need 5-set wins too for checks
                
                // Combine wins for circular dependency check - **NO LONGER NEEDED HERE**
                // const combinedWins = {};
                // const allTeamNames = rankings.map(t => t.name);
                // allTeamNames.forEach(teamName => {
                //     const bo5 = fiveSetWins[teamName] || [];
                //     const bo3 = bestOf3Wins[teamName] || [];
                //     combinedWins[teamName] = [...new Set([...bo5, ...bo3])]; // Combine and remove duplicates
                // });
                
                let totalAdjustments = 0;
                
                // Create a list of adjustments to process
                const adjustmentsToProcess = [];
                for (const winnerName in bestOf3Wins) {
                    for (const loserName of bestOf3Wins[winnerName]) {
                        adjustmentsToProcess.push({ winner: winnerName, loser: loserName });
                    }
                }
                
                logDebug(`Found ${adjustmentsToProcess.length} potential Best-of-3 adjustments.`);
                
                // Process each potential adjustment
                for (const adjustment of adjustmentsToProcess) {
                    const winner = rankings.find(team => team.name === adjustment.winner);
                    const loser = rankings.find(team => team.name === adjustment.loser);
                    
                    if (!winner || !loser) {
                        logDebug(`⚠️ Bo3: Could not find winner ${adjustment.winner} or loser ${adjustment.loser}, skipping`);
                        continue;
                    }
                    
                    // Re-sort rankings by current adjusted rank before each check
                        rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
                        
                    const loserIndex = rankings.findIndex(team => team.name === loser.name);
                    const winnerIndex = rankings.findIndex(team => team.name === winner.name);
                    
                    // Check if winner is currently ranked below the loser
                    if (winnerIndex > loserIndex) {
                        logDebug(`Found Bo3 win: ${winner.name} (rank ${winnerIndex+1}) beat ${loser.name} (rank ${loserIndex+1})`);
                        
                        // *** PRECEDENCE CHECK 1: Loser beat Winner in 5 sets? ***
                        const loserWonFiveSet = fiveSetWins[loser.name] && fiveSetWins[loser.name].includes(winner.name);
                        if (loserWonFiveSet) {
                            logDebug(`❌ Bo3 Adjustment Skipped: ${loser.name} previously beat ${winner.name} in a 5-set match. 5-set result takes precedence.`);
                            continue; 
                        }

                        // *** PRECEDENCE CHECK 2: Would this adjustment make Winner jump over a team C that beat Winner in 5 sets? ***
                        let blockedByFiveSetPrecedence = false;
                        for (let i = loserIndex; i < winnerIndex; i++) { // Iterate teams between loser and winner
                            const teamC = rankings[i];
                            // Check if team C beat the current Bo3 winner (winner) in 5 sets
                            if (fiveSetWins[teamC.name] && fiveSetWins[teamC.name].includes(winner.name)) {
                                // *** NEW CHECK: Only block if the Bo5 win was decisive (winner did NOT also beat teamC in 5 sets) ***
                                if (!hasBo5Win(winner.name, teamC.name)) {
                                    logDebug(`❌ Bo3 Adjustment Skipped: Cannot adjust ${winner.name} above ${loser.name} because ${teamC.name} (rank ${i+1}) beat ${winner.name} decisively in 5 sets.`);
                                    blockedByFiveSetPrecedence = true;
                                    break; // Found a decisive blocker, no need to check further
                                } else {
                                    // Log that a split series was found but didn't block
                                    logDebug(`ℹ️ Bo3 Precedence Check: ${teamC.name} (rank ${i+1}) beat ${winner.name} in Bo5, but it was a split series. Adjustment not blocked by this match.`);
                                }
                            }
                        }
                        if (blockedByFiveSetPrecedence) {
                            continue; // Skip this Bo3 adjustment
                        }

                        // *** END PRECEDENCE CHECKS ***
                        
                        // Check for Bo3-only circular dependency
                        const hasBo3Circular = hasCircularDependencyBo3(loser.name, winner.name, bestOf3Wins); // Pass only bestOf3Wins
                        
                        if (!hasBo3Circular) {
                            logDebug(`✅ Bo3 Adjustment: No 5-set precedence conflict or Bo3 circular dependency. Magneting ${winner.name} above ${loser.name}.`);
                            
                            const targetIndex = loserIndex; // Position directly above loser
                            
                            // Assign loser's rank to the winner
                            winner.adjustedRank = rankings[targetIndex].adjustedRank;
                            winner.adjustedDueToBestOf3 = true; // Add new flag
                            winner.beatInBestOf3 = loser.name; // Store opponent name
                            
                            // Increment ranks for teams between the target position and the winner's original position
                            for (let i = targetIndex; i < winnerIndex; i++) {
                                if (rankings[i].name !== winner.name) {
                                    rankings[i].adjustedRank++;
                                }
                            }
                            
                            totalAdjustments++;
                            logDebug(`   ${winner.name} adjusted to rank ${winner.adjustedRank}`);
                        } else {
                            logDebug(`❌ Bo3 Adjustment Skipped: Bo3-only circular dependency detected involving ${winner.name} and ${loser.name}.`);
                        }
                    } else {
                         logDebug(`Bo3: No adjustment needed: ${winner.name} (rank ${winnerIndex+1}) already above ${loser.name} (rank ${loserIndex+1})`);
                         
                         // *** PENALTY CHECK FOR LOSER ***
                         // Check if loser (ranked higher) should be penalized for this loss
                         logDebug(`   Checking if loser ${loser.name} (rank ${loserIndex+1}) should be penalized for losing to lower-ranked ${winner.name} (rank ${winnerIndex+1})`);
                         
                         // Check if the loser holds a Bo5 win over the winner (which protects them from penalty)
                         // Check if the loser holds a Bo5 win over the winner (which protects them from penalty)
                         const loserWonFiveSet = fiveSetWins[loser.name] && fiveSetWins[loser.name].includes(winner.name); // <-- Make sure this line exists
                         // Check if the loser also holds a Bo3 win over the winner (split Bo3 series)
                         const loserWonThreeSet = bestOf3Wins[loser.name] && bestOf3Wins[loser.name].includes(winner.name);

                         if (loserWonFiveSet) {
                             logDebug(`   ❌ Penalty Skipped: ${loser.name} is protected by a prior Bo5 win over ${winner.name}.`);
                         } else if (loserWonThreeSet) {
                             logDebug(`   ❌ Penalty Skipped: ${loser.name} also beat ${winner.name} in Bo3 (split series).`);
                         } else {
                             logDebug(`   ⚠️ PENALTY APPLIED: ${loser.name} flagged for Bo3 loss penalty to ${winner.name}.`);
                             loser.penalizedDueToBo3Loss = true;
                             loser.lostBo3To = winner.name;
                             // No rank change here, penalty affects final rating calculation
                         }
                    }
                }
                
                logDebug(`Completed Best-of-3 match adjustments. Total adjustments made: ${totalAdjustments}`);
                
                // Final sort by adjusted rank
                rankings.sort((a, b) => a.adjustedRank - b.adjustedRank);
            }

            // Helper function to check if there's a circular dependency using Best-of-3 wins ONLY
            function hasCircularDependencyBo3(teamA, teamB, bestOf3Wins) {
                // Check if Team B beat Team A in a Best-of-3 match
                if (!bestOf3Wins[teamB] || !bestOf3Wins[teamB].includes(teamA)) {
                    return false;
                }
                
                // Check if there's any team C such that:
                // A beat C (Bo3) AND C beat B (Bo3)
                const teamsBeatenByA_Bo3 = bestOf3Wins[teamA] || [];
                
                for (const teamC of teamsBeatenByA_Bo3) {
                    if (bestOf3Wins[teamC] && bestOf3Wins[teamC].includes(teamB)) {
                        logDebug(`❌ Bo3-Only Circular dependency found: ${teamA} beat ${teamC} (Bo3), ${teamC} beat ${teamB} (Bo3), and ${teamB} beat ${teamA} (Bo3)`);
                        return true;
                    }
                }
                
                logDebug(`✅ No Bo3-only circular dependency found involving ${teamA} and ${teamB}`);
                return false;
            }
            
            // *** NEW FUNCTION to log Top 10 Adjustments ***
            // Updated to show ratings at key stages
            // Corrected parameter name to match passed variable
            function logTop10Adjustments(rankings, preLeagueAdjRatings) { // Pass preLeagueAdjRatings
                const top10InfoDiv = document.getElementById('top10-adj-info');
                if (!top10InfoDiv) {
                    console.error('Could not find the top10-adj-info div');
                    return;
                }
                
                top10InfoDiv.innerHTML = ''; // Clear previous logs
                top10InfoDiv.style.maxHeight = '300px'; // Give it a max height
                top10InfoDiv.style.overflowY = 'auto'; // Allow scrolling
                top10InfoDiv.style.border = '1px solid #eee'; // Add border like debug
                top10InfoDiv.style.padding = '10px'; // Add padding
                top10InfoDiv.style.marginTop = '10px'; // Add margin top
                top10InfoDiv.style.fontSize = '0.9em'; // Slightly smaller font
                top10InfoDiv.style.fontFamily = 'monospace'; // Monospace font
                top10InfoDiv.style.backgroundColor = '#f8f8f8'; // Set background color

                const top10 = rankings.slice(0, 10);
                let foundAdjustments = false;

                top10.forEach((team, index) => {
                    const adjLogs = [];
                    const rank = index + 1;

                    // Add Rating Info
                    const initialRating = team.rating !== undefined ? team.rating.toFixed(3) : 'N/A';
                    // Use the correct parameter name here
                    const preLeagueRating = preLeagueAdjRatings[team.name] !== undefined ? preLeagueAdjRatings[team.name].toFixed(3) : 'N/A';
                    const finalRating = team.adjustedRating !== undefined ? team.adjustedRating.toFixed(3) : 'N/A';
                    
                    adjLogs.push(`  Ratings: Initial=${initialRating}, Pre-League=${preLeagueRating}, Final=${finalRating}`);

                    // Check for 5-set adjustment
                    if (team.adjustedDueToFiveSet) {
                        adjLogs.push(`- H2H Rule: Adjusted UP (5-set win over ${team.beatInFiveSet || 'N/A'})`);
                        foundAdjustments = true;
                    }
                    
                    // Check for Best-of-3 adjustment (UP)
                    if (team.adjustedDueToBestOf3) {
                        adjLogs.push(`- H2H Rule: Adjusted UP (Bo3 win over ${team.beatInBestOf3 || 'N/A'})`);
                        foundAdjustments = true;
                    }
                    
                    // Check for Best-of-3 PENALTY (rating decrease, not rank swap)
                    if (team.penalizedDueToBo3Loss) {
                        adjLogs.push(`- H2H Rule: Penalized (Bo3 loss to ${team.lostBo3To || 'N/A'})`);
                        foundAdjustments = true;
                    }
                    
                    // Check for Best-of-3 rank swap (DOWN)
                    // Note: This flag might not be set if penalty applied instead?
                    if (team.adjustedDownDueToBestOf3) { 
                        adjLogs.push(`- H2H Rule: Adjusted DOWN (Bo3 loss to ${team.lostBo3To || 'N/A'})`);
                        foundAdjustments = true;
                    }

                    // Check for Undefeated adjustment
                    if (team.adjustedDueToUndefeated) {
                        adjLogs.push(`- H2H Rule: Adjusted (Undefeated, vs ${team.bestBeatenTeam || 'N/A'})`);
                        foundAdjustments = true;
                    }
                    if (team.exemptedFromAdjustment) {
                        adjLogs.push(`- H2H Rule: NOT Adjusted (Undefeated, ${team.record?.wins || '?'} wins >= 15)`);
                        // Don't set foundAdjustments = true for exemption note
                    }
                    
                    // Check for League adjustment (UP/DOWN)
                    if (team.adjustedDueToLeague || team.adjustedDownDueToLeague) {
                         if (team.adjustedDueToLeague) {
                            adjLogs.push(`- League Rule: Adjusted UP (Better league rank than ${team.leaguePositionOver || 'N/A'})`);
                         }
                         if (team.adjustedDownDueToLeague) {
                            adjLogs.push(`- League Rule: Adjusted DOWN (Worse league rank than ${team.movedDownFor || 'N/A'})`);
                         }
                         foundAdjustments = true;
                    } else if (team.adjustedDueToSplitOverride) {
                         // Special override for split where higher league rank team kept pre-league rating
                         adjLogs.push(`- League Rule: Kept Pre-League Rating (Split Override vs ${team.magnetPartner || 'N/A'})`);
                         foundAdjustments = true;
                    } else if (team.adjustedDueToSplitMagnet) {
                         // Team magneted below partner due to split override or post-league magnet
                         adjLogs.push(`- League Rule: Magneted below ${team.magnetPartner || 'N/A'} (Split Pair)`);
                         foundAdjustments = true;
                    }

                    // Log only if there are details beyond just ratings
                    if (adjLogs.length > 1) { 
                        const teamLog = document.createElement('div');
                        teamLog.style.marginBottom = '8px'; // Add more space between teams
                        teamLog.style.borderBottom = '1px dashed #eee'; // Add separator
                        teamLog.style.paddingBottom = '5px';
                        teamLog.innerHTML = `<strong>#${rank} ${team.name}:</strong><br>` + adjLogs.join('<br>');
                        top10InfoDiv.appendChild(teamLog);
                    }
                });

                if (!foundAdjustments) {
                    top10InfoDiv.textContent = 'No specific H2H or League rule adjustments applied within the Top 10.';
                }
            }
        });
    </script>
    
    <script>
        // Add copy-to-clipboard functionality
        document.addEventListener('DOMContentLoaded', function() {
            const copyDebugBtn = document.getElementById('copy-debug');
            if (copyDebugBtn) {
                copyDebugBtn.addEventListener('click', function() {
                    const debugContent = document.getElementById('debug-info').innerText;
                    navigator.clipboard.writeText(debugContent).then(function() {
                        // Temporarily change the button icon to indicate success
                        const iconElement = copyDebugBtn.querySelector('i');
                        iconElement.className = 'fa-solid fa-check';
                        setTimeout(function() {
                            iconElement.className = 'fa-solid fa-copy';
                        }, 1500);
                    }).catch(function(err) {
                        console.error('Could not copy text: ', err);
                        alert('Failed to copy debug information to clipboard');
                    });
                });
            }
        });
    </script>

    <script>
    /**
     * If the phone is in portrait, tell Safari/Chrome to
     * render the page as if the viewport were 850 px wide
     * (≈ your desktop width) – mobile Safari will then "zoom out"
     * so everything fits.  In landscape we restore the normal rule.
     */
    function updateViewport () {
      const vp = document.getElementById('viewportMeta');
      const portrait = window.matchMedia('(orientation: portrait)').matches;
      if (portrait) {
        vp.setAttribute('content', 'width=850');
      } else {
        vp.setAttribute('content', 'width=device-width, initial-scale=1.0');
      }
    }
    window.addEventListener('load', updateViewport);
    window.addEventListener('orientationchange', updateViewport);
    window.addEventListener('resize', updateViewport);
    </script>

</body>
</html>